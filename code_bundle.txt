## Code Bundle - Aggregated Files

---- File: src\common\data\devicesChartData.ts ----
// src/common/data/devicesChartData.ts

// Datos mock para el grÃ¡fico de dispositivos online por dÃ­a
const devicesChartData = [
  { "date": "2025-09-01", "online": 1015 },
  { "date": "2025-09-02", "online": 1023 },
  { "date": "2025-09-03", "online": 1018 },
  { "date": "2025-09-04", "online": 1030 },
  { "date": "2025-09-05", "online": 1025 },
  { "date": "2025-09-06", "online": 1011 },
  { "date": "2025-09-07", "online": 1005 },
  { "date": "2025-09-08", "online": 1035 },
  { "date": "2025-09-09", "online": 1042 },
  { "date": "2025-09-10", "online": 1038 },
  { "date": "2025-09-11", "online": 1050 },
  { "date": "2025-09-12", "online": 1045 },
  { "date": "2025-09-13", "online": 1033 },
  { "date": "2025-09-14", "online": 1028 },
  { "date": "2025-09-15", "online": 1055 },
  { "date": "2025-09-16", "online": 1060 },
  { "date": "2025-09-17", "online": 1052 },
  { "date": "2025-09-18", "online": 1065 },
  { "date": "2025-09-19", "online": 1058 },
  { "date": "2025-09-20", "online": 1045 },
  { "date": "2025-09-21", "online": 1040 },
  { "date": "2025-09-22", "online": 1070 },
  { "date": "2025-09-23", "online": 1075 },
  { "date": "2025-09-24", "online": 1068 },
  { "date": "2025-09-25", "online": 1080 },
  { "date": "2025-09-26", "online": 1072 },
  { "date": "2025-09-27", "online": 1060 },
  { "date": "2025-09-28", "online": 1055 },
  { "date": "2025-09-29", "online": 1085 },
  { "date": "2025-09-30", "online": 1090 }
];

export { devicesChartData };

---- File: src\common\data\devicesKpis.ts ----
// src/common/data/devicesKpis.ts

// NOTA: sin types, mismo estilo que invoiceList.ts
// Campos compatibles con el widget de KPIs (InvoiceList)
const devicesKpis = [
  {
    id: 1,
    label: "Total Devices",
    percentage: "+2.3 %",
    percentageClass: "success", // success | danger
    icon: "ri-arrow-right-up-line",
    counter: 1255,
    badge: "1,255",
    caption: "Devices registered",
    feaIcon: "cpu", // Feather icon
    decimals: 0,
    prefix: "",
    suffix: "",
  },
  {
    id: 2,
    label: "Online",
    percentage: "+1.1 %",
    percentageClass: "success",
    icon: "ri-arrow-right-up-line",
    counter: 1024,
    badge: "1,024",
    caption: "Online now",
    feaIcon: "wifi",
    decimals: 0,
    prefix: "",
    suffix: "",
  },
  {
    id: 3,
    label: "Offline",
    percentage: "-0.7 %",
    percentageClass: "danger",
    icon: "ri-arrow-right-down-line",
    counter: 186,
    badge: "186",
    caption: "Disconnected",
    feaIcon: "wifi-off",
    decimals: 0,
    prefix: "",
    suffix: "",
  },
  {
    id: 4,
    label: "Active Alarms",
    percentage: "+5.0 %",
    percentageClass: "danger",
    icon: "ri-arrow-right-down-line",
    counter: 37,
    badge: "37",
    caption: "Open alerts",
    feaIcon: "alert-triangle",
    decimals: 0,
    prefix: "",
    suffix: "",
  },
];

export { devicesKpis };

---- File: src\common\data\devicesMockData.ts ----
// src/common/data/devicesMockData.ts

// Datos mock para la tabla de dispositivos
const devicesMockData = [
  {
    id: 1,
    mssSerial: "MSS-001",
    substation: "SubestaciÃ³n Norte",
    supplyPoint: "Punto 01",
    meterBrand: "Brand A",
    meterSerial: "MET-001",
    status: "online",
    lastUpdate: "2025-09-15T10:30:00Z",
    lat: 18.4961,
    lng: -69.9412
  },
  {
    id: 2,
    mssSerial: "MSS-002",
    substation: "SubestaciÃ³n Sur",
    supplyPoint: "Punto 02",
    meterBrand: "Brand B",
    meterSerial: "MET-002",
    status: "offline",
    lastUpdate: "2025-09-14T15:45:00Z",
    lat: 18.4761,
    lng: -69.9212
  },
  {
    id: 3,
    mssSerial: "MSS-003",
    substation: "SubestaciÃ³n Este",
    supplyPoint: "Punto 03",
    meterBrand: "Brand C",
    meterSerial: "MET-003",
    status: "maintenance",
    lastUpdate: "2025-09-15T08:15:00Z",
    lat: 18.4861,
    lng: -69.9112
  },
  {
    id: 4,
    mssSerial: "MSS-004",
    substation: "SubestaciÃ³n Oeste",
    supplyPoint: "Punto 04",
    meterBrand: "Brand A",
    meterSerial: "MET-004",
    status: "online",
    lastUpdate: "2025-09-15T11:20:00Z",
    lat: 18.4661,
    lng: -69.9512
  },
  {
    id: 5,
    mssSerial: "MSS-005",
    substation: "SubestaciÃ³n Central",
    supplyPoint: "Punto 05",
    meterBrand: "Brand D",
    meterSerial: "MET-005",
    status: "online",
    lastUpdate: "2025-09-15T09:45:00Z",
    lat: 18.4895,
    lng: -69.9340
  }
];

export { devicesMockData };

---- File: src\common\data\index.ts ----
import { topPages, allData, monthData, halfyearData, allaudiencesMetricsData, monthaudiencesMetricsData, halfyearaudiencesMetricsData, yaeraudiencesMetricsData, todayDeviceData, lastWeekDeviceData, lastMonthDeviceData, currentYearDeviceData, todayaudiencesCountryData, lastWeekaudiencesCountryData, lastMonthaudiencesCountryData, currentyearaudiencesCountryData } from "./analytics";
import {
  crmWidgets,
  dealsStatus,
  tasks,
  activities,
  closingDeals,
  todayBalanceData, lastWeekBalanceData, lastMonthBalanceData, currentYearBalanceData, todayDealData, weeklyDealData, monthlyDealData, yealyDealData, octData, novData, decData, janData
} from "./dashboardcrm";
import {
  ecomWidgets,
  bestSellingProducts,
  topSellers,
  recentOrders,
  topCategories,
  allRevenueData, monthRevenueData, halfYearRevenueData, yearRevenueData
} from "./dashboardEcommerce";
import {
  cyptoWidgets,
  currencies,
  recentActivity,
  topPerformers,
  newsFeed,
  cryptoSlider,
  btcPortfolioData, usdPortfolioData, euroPortfolioData, MarketGraphAll, MarketGraphYear, MarketGraphMonth, MarketGraphWeek, MarketGraphHour
} from "./crypto";
import {
  blogwidget,
  socialShares,
  comments,
  recentTable
} from "./dashboardblog";
import { apiKey } from "./apiKey";
import {
  projectsWidgets,
  activeProjects,
  projectTasks,
  teamMembers,
  overviewCounter, allProjectData, monthProjectData, halfyearProjectData, yearProjectData, allTimeData, lastWeekData, lastMonthData, lastquarterData, dashboardChat
} from "./dashboardProjects";
import { topartWork, featuredNFTData, popularityData, recentNFTsData, topCollectionData, popularCreatorsData, allMarketplaceData, monthMarketplaceData, halfyearMarketplaceData, yearMarketplaceData } from "./dashboardNFT";
import {
  tileBoxs1,
  tileBoxs2,
  tileBoxs3,
  tileBoxes4,
  tileBoxes5,
  widgetsActivities,
  widgetsAudiences,
  widgetsPortfolio,
  widgetsTasks,
  otherWidgets2
} from "./widgets";
import { taskWidgets, allTask, kanbanBoardData } from "./taskList";
import { invoiceWidgets, invoiceTable } from "./invoiceList";
import {
  projectList,
} from "./projectList";

import { calenderDefaultCategories, events, defaultevent } from "./calender";
import { chatMessage, messages, chatContactData } from "./chat";
import { mailbox } from "./mailbox";
import { transactions, buysellWidgets, market, CryptoOrders, watchlist, marketStatus, CryptoicoWidgets, icoWidgetsList } from "./cryptoPage";
import { ticketsWidgets, ticketsTable } from "./supportTickets";

// Pages
import { gallery, pricing1, pricing2, pricing3, projects, documents, SearchGallery, news, video, swiper, team } from "./pagesData";

import { jobApplication, jobCandidates, jobCategories, } from "./appsJobs";

import country from "./country";

import { listData, gridData } from "./pageblog"

import { headData, tasklist, AddTeamMember } from "./kanban";

//Ecommerce
import {
  productsData,
  productDetailsWidgets,
  reviews,
  orders,
  productDetails,
  customerList,
  shoppingCart,
  orderSummary,
  sellersList,
  revenueWidgets,
  productsReview,
} from "./ecommerce";

import { crmcontacts, companies, leads, deals } from "./crm";

import {
  expolreNow, aution, NFTRanking, creatorsData, creatorsListData, walletConnectData, topDrop, topCreator, topCollection, tradingArtworkData,
  nftArtworkData,
  popularCreatorsNFT, marketPlacewidget
} from "./NFTMarketplace";

import { connectData, discoverItemsData, featuresData, productData, topCreatorData } from "./LandingNFT";

import { recentFile, folderList } from "./fileManager";

import { todoTaskList, todoCollapse } from "./todoData";

import { applicationsStatisticData } from "./dashboardJobs";

export {
  applicationsStatisticData,
  topPages,
  crmWidgets,
  cryptoSlider,
  dealsStatus,
  tasks,
  activities,
  closingDeals,
  ecomWidgets,
  bestSellingProducts,
  topSellers,
  recentOrders,
  topCategories,
  cyptoWidgets,
  currencies,
  topPerformers,
  recentActivity,
  headData, tasklist, AddTeamMember,
  newsFeed,
  projectsWidgets,
  activeProjects,
  projectTasks,
  teamMembers,
  overviewCounter,
  tileBoxs1,
  tileBoxs2,
  tileBoxs3,
  tileBoxes4,
  tileBoxes5,
  widgetsActivities,
  widgetsAudiences,
  widgetsPortfolio,
  widgetsTasks,
  taskWidgets,
  allTask,
  kanbanBoardData,
  invoiceWidgets,
  invoiceTable,
  projectList,
  chatMessage,
  messages,
  calenderDefaultCategories,
  events,
  defaultevent,
  mailbox,
  productsData,
  productDetailsWidgets,
  reviews,
  orders,
  productDetails,
  customerList,
  shoppingCart,
  orderSummary,
  sellersList,
  revenueWidgets,
  productsReview,
  crmcontacts,
  companies,
  leads,
  deals,
  transactions,
  buysellWidgets,
  market,
  CryptoOrders,
  watchlist,
  marketStatus,
  CryptoicoWidgets,
  icoWidgetsList,
  ticketsWidgets,
  ticketsTable,
  otherWidgets2,
  expolreNow,
  aution,
  NFTRanking,
  creatorsData,
  creatorsListData,
  walletConnectData,
  topDrop,
  topCreator,
  topCollection,
  topartWork, featuredNFTData, popularityData, recentNFTsData, topCollectionData, popularCreatorsData, tradingArtworkData,
  nftArtworkData,
  popularCreatorsNFT, marketPlacewidget,
  connectData, discoverItemsData, featuresData, productData, topCreatorData, allData, monthData, halfyearData, allaudiencesMetricsData, monthaudiencesMetricsData, halfyearaudiencesMetricsData, yaeraudiencesMetricsData, todayDeviceData, lastWeekDeviceData, lastMonthDeviceData, currentYearDeviceData, todayBalanceData, lastWeekBalanceData, lastMonthBalanceData, currentYearBalanceData, todayDealData, weeklyDealData, monthlyDealData, yealyDealData, octData, novData, decData, janData, allRevenueData, monthRevenueData, halfYearRevenueData, yearRevenueData, btcPortfolioData, usdPortfolioData, euroPortfolioData, MarketGraphAll, MarketGraphYear, MarketGraphMonth, MarketGraphWeek, MarketGraphHour, allProjectData, monthProjectData, halfyearProjectData, yearProjectData, allTimeData, lastWeekData, lastMonthData, lastquarterData, allMarketplaceData, monthMarketplaceData, halfyearMarketplaceData, yearMarketplaceData, todayaudiencesCountryData, lastWeekaudiencesCountryData, lastMonthaudiencesCountryData, currentyearaudiencesCountryData, dashboardChat, gallery, pricing1, pricing2, pricing3, projects, documents, SearchGallery, news, video, swiper, team,
  recentFile, folderList, todoTaskList, chatContactData, todoCollapse,
  jobApplication,
  apiKey,
  country,
  jobCandidates,
  jobCategories,
  blogwidget,
  socialShares,
  comments,
  recentTable,
  listData,
  gridData
};

export { devicesKpis } from "./devicesKpis";
export { devicesMockData } from "./devicesMockData"; 
export { devicesChartData} from "./devicesChartData"

---- File: src\helpers\AuthType\fakeBackend.ts ----
import axios from "axios";
import MockAdapter from "axios-mock-adapter";
import * as url from "../url_helper";
import { accessToken, nodeApiToken } from "../jwt-token-access/accessToken";

import {
  calenderDefaultCategories,
  events,
  defaultevent,
  messages,
  chatMessage,
  projectList,
  sellersList,
  transactions,
  CryptoOrders,
  deals,
  mailbox,
  allData,
  monthData,
  halfyearData,
  allaudiencesMetricsData,
  monthaudiencesMetricsData,
  halfyearaudiencesMetricsData,
  yaeraudiencesMetricsData,
  todayDeviceData,
  lastWeekDeviceData,
  lastMonthDeviceData,
  currentYearDeviceData,
  todayBalanceData,
  lastWeekBalanceData,
  lastMonthBalanceData,
  currentYearBalanceData,
  todayDealData,
  weeklyDealData,
  monthlyDealData,
  yealyDealData,
  octData,
  novData,
  decData,
  janData,
  allRevenueData,
  monthRevenueData,
  halfYearRevenueData,
  yearRevenueData,
  btcPortfolioData,
  usdPortfolioData,
  euroPortfolioData,
  MarketGraphAll,
  MarketGraphYear,
  MarketGraphMonth,
  MarketGraphWeek,
  MarketGraphHour,
  allProjectData,
  monthProjectData,
  halfyearProjectData,
  yearProjectData,
  allTimeData,
  lastWeekData,
  lastMonthData,
  lastquarterData,
  allMarketplaceData,
  monthMarketplaceData,
  halfyearMarketplaceData,
  yearMarketplaceData,
  todayaudiencesCountryData,
  lastWeekaudiencesCountryData,
  lastMonthaudiencesCountryData,
  currentyearaudiencesCountryData,
  team,
  jobApplication,
  folderList,
  recentFile,
  todoTaskList,
  todoCollapse,
  apiKey,
  applicationsStatisticData,
  customerList,
  orders,
  productsData,
  ticketsTable,
  allTask,
  jobCandidates,
  jobCategories,
  leads,
  companies,
  crmcontacts,
  tasklist,
  devicesKpis,
  devicesMockData,
  devicesChartData 
} from "../../common/data";



let users = [
  {
    uid: 1,
    username: "admin",
    role: "admin",
    password: "123456",
    email: "admin@themesbrand.com",
  },
];

const fakeBackend = () => {
  // This sets the mock adapter on the default instance
  const mock = new MockAdapter(axios, { onNoMatch: "passthrough" });

  mock.onPost("/post-jwt-register").reply((config: any) => {
    const user = JSON.parse(config["data"]);
    users.push(user);

    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve([200, user]);
      });
    });
  });

  mock.onPost("/post-jwt-login").reply((config: any) => {
    const user = JSON.parse(config["data"]);
    const validUser = users.filter(
      usr => usr.email === user.email && usr.password === user.password
    );

    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (validUser["length"] === 1) {
          // You have to generate AccessToken by jwt. but this is fakeBackend so, right now its dummy
          const token = accessToken;

          // JWT AccessToken
          const tokenObj = { accessToken: token }; // Token Obj
          const validUserObj = { ...validUser[0], ...tokenObj }; // validUser Obj

          resolve([200, validUserObj]);
        } else {
          reject([
            400,
            "Username and password are invalid. Please enter correct username and password",
          ]);
        }
      });
    });
  });

  mock.onPost("/post-jwt-profile").reply((config: any) => {
    const user = JSON.parse(config["data"]);

    const one = config.headers;

    let finalToken = one.Authorization;

    const validUser = users.filter(usr => usr.uid === user.idx);

    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // Verify Jwt token from header.Authorization
        if (finalToken === accessToken) {
          if (validUser["length"] === 1) {
            let objIndex;

            //Find index of specific object using findIndex method.
            objIndex = users.findIndex(obj => obj.uid === user.idx);

            //Update object's name property.
            users[objIndex].username = user.username;

            // Assign a value to locastorage
            sessionStorage.removeItem("authUser");
            sessionStorage.setItem("authUser", JSON.stringify(users[objIndex]));

            resolve([200, "Profile Updated Successfully"]);
          } else {
            reject([400, "Something wrong for edit profile"]);
          }
        } else {
          reject([400, "Invalid Token !!"]);
        }
      });
    });
  });

  mock.onPost("/social-login").reply((config: any) => {
    const user = JSON.parse(config["data"]);
    return new Promise((resolve, reject) => {

      setTimeout(() => {
        if (user && user.token) {
          // You have to generate AccessToken by jwt. but this is fakeBackend so, right now its dummy
          const token = accessToken;
          const first_name = user.name;
          const nodeapiToken = nodeApiToken;
          delete user.name;

          // JWT AccessToken
          const tokenObj = { accessToken: token, first_name: first_name }; // Token Obj
          const validUserObj = { token: nodeapiToken, "data": { ...tokenObj, ...user } }; // validUser Obj
          resolve([200, validUserObj]);
        } else {
          reject([
            400,
            "Username and password are invalid. Please enter correct username and password",
          ]);
        }
      });
    });
  });

  // Calendar
  mock.onGet(url.GET_EVENTS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (events) {
          // Passing fake JSON data as response
          const data = [...events, ...defaultevent];
          resolve([200, data]);
        } else {
          reject([400, "Cannot get events"]);
        }
      });
    });
  });

  mock.onGet(url.GET_CATEGORIES).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (calenderDefaultCategories) {
          // Passing fake JSON data as response
          resolve([200, calenderDefaultCategories]);
        } else {
          reject([400, "Cannot get categories"]);
        }
      });
    });
  });

  mock.onGet(url.GET_UPCOMMINGEVENT).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (defaultevent) {
          const data = [...defaultevent, ...events];
          // Passing fake JSON data as response
          resolve([200, data]);
        } else {
          reject([400, "Cannot get upcomming events"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_EVENT).reply((event) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot add event"]);
        }
      });
    });
  });

  // crm companies

  mock.onPost(url.ADD_NEW_COMPANIES).reply((company) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (company && company.data) {
          // Passing fake JSON data as response
          resolve([200, company.data]);
        } else {
          reject([400, "Cannot add company"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_EVENT).reply((event) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_EVENT).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.event]);
        } else {
          reject([400, "Cannot delete event"]);
        }
      });
    });
  });

  // Chat
  mock.onGet(url.GET_DIRECT_CONTACT).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (chatMessage) {
          // Passing fake JSON data as response
          resolve([200, chatMessage]);
        } else {
          reject([400, "Cannot get direct contact"]);
        }
      });
    });
  });

  mock.onGet(new RegExp(`${url.GET_MESSAGES}/*`)).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (messages) {
          // Passing fake JSON data as response
          const { params } = config;
          const filteredMessages = messages.filter(
            msg => msg.roomId === params.roomId
          );

          resolve([200, filteredMessages]);
        } else {
          reject([400, "Cannot get messages"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_MESSAGE).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config.data) {
          // Passing fake JSON data as response
          resolve([200, config.data]);
        } else {
          reject([400, "Cannot add message"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_MESSAGE).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.message]);
        } else {
          reject([400, "Cannot delete message"]);
        }
      });
    });
  });


  // Project > List
  mock.onGet(url.GET_PROJECT_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (projectList) {
          // Passing fake JSON data as response
          resolve([200, projectList]);
        } else {
          reject([400, "Cannot get project list data"]);
        }
      });
    });
  });

  // MailBox
  mock.onGet(url.GET_MAIL_DETAILS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (mailbox) {
          // Passing fake JSON data as response
          resolve([200, mailbox]);
        } else {
          reject([400, "Cannot get mail details"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_MAIL).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.forId]);
        } else {
          reject([400, "Cannot delete order"]);
        }
      });
    });
  });
  

  mock.onDelete(url.UNREAD_MAIL).reply(config => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.forId]);
        } else {
          reject([400, "Cannot Stared Mail"]);
        }
      });
    });
  });

  mock.onDelete(url.STARED_MAIL).reply(config => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.forId]);
        } else {
          reject([400, "Cannot Stared Mail"]);
        }
      });
    });
  });

  mock.onDelete(url.LABEL_MAIL).reply(config => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.forId]);
        } else {
          reject([400, "Try Sometime Later"]);
        }
      });
    });
  });

  mock.onDelete(url.TRASH_MAIL).reply(config => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.forId]);
        } else {
          reject([400, "Cannot Trash Mail"]);
        }
      });
    });
  });

  // Ecommerce > Seller
  mock.onGet(url.GET_SELLERS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (sellersList) {
          // Passing fake JSON data as response
          resolve([200, sellersList]);
        } else {
          reject([400, "Cannot get sellers"]);
        }
      });
    });
  });

  // Crypto > Transaction
  mock.onGet(url.GET_TRANSACTION_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (transactions) {
          // Passing fake JSON data as response
          resolve([200, transactions]);
        } else {
          reject([400, "Cannot get Transactions Data"]);
        }
      });
    });
  });

  // Crypto > Orders
  mock.onGet(url.GET_ORDRER_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (CryptoOrders) {
          // Passing fake JSON data as response
          resolve([200, CryptoOrders]);
        } else {
          reject([400, "Cannot get Order Data"]);
        }
      });
    });
  });

  // CRM > Deals
  mock.onGet(url.GET_DEALS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (deals) {
          // Passing fake JSON data as response
          resolve([200, deals]);
        } else {
          reject([400, "Cannot get Deals"]);
        }
      });
    });
  });

  // Dashborad Analytics
  // Sessions by Countries

  mock.onGet(url.GET_ALL_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allData) {
          // Passing fake JSON data as response
          resolve([200, allData]);
        } else {
          reject([400, "Cannot get All Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHLY_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthData) {
          // Passing fake JSON data as response
          resolve([200, monthData]);
        } else {
          reject([400, "Cannot get Monthly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HALFYEARLY_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (halfyearData) {
          // Passing fake JSON data as response
          resolve([200, halfyearData]);
        } else {
          reject([400, "Cannot get Half Yealy Chart Data"]);
        }
      });
    });
  });

  // Audiences Metrics
  mock.onGet(url.GET_ALLAUDIENCESMETRICS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allaudiencesMetricsData) {
          // Passing fake JSON data as response
          resolve([200, allaudiencesMetricsData]);
        } else {
          reject([400, "Cannot get All Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHLYAUDIENCESMETRICS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthaudiencesMetricsData) {
          // Passing fake JSON data as response
          resolve([200, monthaudiencesMetricsData]);
        } else {
          reject([400, "Cannot get Monthly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HALFYEARLYAUDIENCESMETRICS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (halfyearaudiencesMetricsData) {
          // Passing fake JSON data as response
          resolve([200, halfyearaudiencesMetricsData]);
        } else {
          reject([400, "Cannot get Half Yealy Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARLYAUDIENCESMETRICS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (yaeraudiencesMetricsData) {
          // Passing fake JSON data as response
          resolve([200, yaeraudiencesMetricsData]);
        } else {
          reject([400, "Cannot get Yealy Chart Data"]);
        }
      });
    });
  });

  // Users by Device
  mock.onGet(url.GET_TODAYDEVICE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todayDeviceData) {
          // Passing fake JSON data as response
          resolve([200, todayDeviceData]);
        } else {
          reject([400, "Cannot get Today Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTWEEKDEVICE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastWeekDeviceData) {
          // Passing fake JSON data as response
          resolve([200, lastWeekDeviceData]);
        } else {
          reject([400, "Cannot get Last Weekly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTMONTHDEVICE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastMonthDeviceData) {
          // Passing fake JSON data as response
          resolve([200, lastMonthDeviceData]);
        } else {
          reject([400, "Cannot get Last Montly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_CURRENTYEARDEVICE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (currentYearDeviceData) {
          // Passing fake JSON data as response
          resolve([200, currentYearDeviceData]);
        } else {
          reject([400, "Cannot get Current Yealy Chart Data"]);
        }
      });
    });
  });

  // Audiences Sessions by Country

  mock.onGet(url.GET_TODAYSESSION_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todayaudiencesCountryData) {
          // Passing fake JSON data as response
          resolve([200, todayaudiencesCountryData]);
        } else {
          reject([400, "Cannot get Today Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTWEEKSESSION_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastWeekaudiencesCountryData) {
          // Passing fake JSON data as response
          resolve([200, lastWeekaudiencesCountryData]);
        } else {
          reject([400, "Cannot get Last Weekly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTMONTHSESSION_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastMonthaudiencesCountryData) {
          // Passing fake JSON data as response
          resolve([200, lastMonthaudiencesCountryData]);
        } else {
          reject([400, "Cannot get Last Montly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_CURRENTYEARSESSION_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (currentyearaudiencesCountryData) {
          // Passing fake JSON data as response
          resolve([200, currentyearaudiencesCountryData]);
        } else {
          reject([400, "Cannot get Current Yealy Chart Data"]);
        }
      });
    });
  });

  // Dashboard CRM

  // Balance Overview
  mock.onGet(url.GET_TODAYBALANCE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todayBalanceData) {
          // Passing fake JSON data as response
          resolve([200, todayBalanceData]);
        } else {
          reject([400, "Cannot get Today Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTWEEKBALANCE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastWeekBalanceData) {
          // Passing fake JSON data as response
          resolve([200, lastWeekBalanceData]);
        } else {
          reject([400, "Cannot get Last Weekly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_LASTMONTHBALANCE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastMonthBalanceData) {
          // Passing fake JSON data as response
          resolve([200, lastMonthBalanceData]);
        } else {
          reject([400, "Cannot get Last Montly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_CURRENTYEARBALANCE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (currentYearBalanceData) {
          // Passing fake JSON data as response
          resolve([200, currentYearBalanceData]);
        } else {
          reject([400, "Cannot get Current Yealy Chart Data"]);
        }
      });
    });
  });

  // Deal Type
  mock.onGet(url.GET_TODAYDEAL_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todayDealData) {
          // Passing fake JSON data as response
          resolve([200, todayDealData]);
        } else {
          reject([400, "Cannot get Today Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_WEEKLYDEAL_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (weeklyDealData) {
          // Passing fake JSON data as response
          resolve([200, weeklyDealData]);
        } else {
          reject([400, "Cannot get Weekly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHLYDEAL_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthlyDealData) {
          // Passing fake JSON data as response
          resolve([200, monthlyDealData]);
        } else {
          reject([400, "Cannot get Montly Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARLYDEAL_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (yealyDealData) {
          // Passing fake JSON data as response
          resolve([200, yealyDealData]);
        } else {
          reject([400, "Cannot get Yealy Chart Data"]);
        }
      });
    });
  });

  // Sales Forecast
  mock.onGet(url.GET_OCTSALES_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (octData) {
          // Passing fake JSON data as response
          resolve([200, octData]);
        } else {
          reject([400, "Cannot get October Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_NOVSALES_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (novData) {
          // Passing fake JSON data as response
          resolve([200, novData]);
        } else {
          reject([400, "Cannot get November Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_DECSALES_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (decData) {
          // Passing fake JSON data as response
          resolve([200, decData]);
        } else {
          reject([400, "Cannot get December Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_JANSALES_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (janData) {
          // Passing fake JSON data as response
          resolve([200, janData]);
        } else {
          reject([400, "Cannot get January Chart Data"]);
        }
      });
    });
  });
  // Dashboard Ecommerce
  // Revenue
  mock.onGet(url.GET_ALLREVENUE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allRevenueData) {
          // Passing fake JSON data as response
          resolve([200, allRevenueData]);
        } else {
          reject([400, "Cannot get All Revenue Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHREVENUE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthRevenueData) {
          // Passing fake JSON data as response
          resolve([200, monthRevenueData]);
        } else {
          reject([400, "Cannot get Month Revenue Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HALFYEARREVENUE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (halfYearRevenueData) {
          // Passing fake JSON data as response
          resolve([200, halfYearRevenueData]);
        } else {
          reject([400, "Cannot get Half Year Revenue Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARREVENUE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (yearRevenueData) {
          // Passing fake JSON data as response
          resolve([200, yearRevenueData]);
        } else {
          reject([400, "Cannot get Year Revenue Data"]);
        }
      });
    });
  });

  // Dashboard Job
  // Applications Statistic
  mock.onGet(new RegExp(`${url.GET_APPLICTION_DATA}/*`)).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (applicationsStatisticData) {
          // Passing fake JSON data as response
          const { params } = config;
          const filteredMessages: any = applicationsStatisticData.filter(
            msg => msg.id === params.roomId
          );
          const data = filteredMessages.map((item: any) => item[params.roomId]);
          resolve([200, data[0]]);
        } else {
          reject([400, "Cannot get messages"]);
        }
      });
    });
  });

  // Dashboard Crypto
  // Portfolio
  mock.onGet(url.GET_BTCPORTFOLIO_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (btcPortfolioData) {
          // Passing fake JSON data as response
          resolve([200, btcPortfolioData]);
        } else {
          reject([400, "Cannot get BTC Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_USDPORTFOLIO_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (usdPortfolioData) {
          // Passing fake JSON data as response
          resolve([200, usdPortfolioData]);
        } else {
          reject([400, "Cannot get USD Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_EUROPORTFOLIO_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (euroPortfolioData) {
          // Passing fake JSON data as response
          resolve([200, euroPortfolioData]);
        } else {
          reject([400, "Cannot get EURO Data"]);
        }
      });
    });
  });

  // Market Graph
  mock.onGet(url.GET_ALLMARKETDATA_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (MarketGraphAll) {
          // Passing fake JSON data as response
          resolve([200, MarketGraphAll]);
        } else {
          reject([400, "Cannot get All Market Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARMARKET_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (MarketGraphYear) {
          // Passing fake JSON data as response
          resolve([200, MarketGraphYear]);
        } else {
          reject([400, "Cannot get Year Market Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHMARKET_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (MarketGraphMonth) {
          // Passing fake JSON data as response
          resolve([200, MarketGraphMonth]);
        } else {
          reject([400, "Cannot get Month Market Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_WEEKMARKET_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (MarketGraphWeek) {
          // Passing fake JSON data as response
          resolve([200, MarketGraphWeek]);
        } else {
          reject([400, "Cannot get Week Market Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HOURMARKET_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (MarketGraphHour) {
          // Passing fake JSON data as response
          resolve([200, MarketGraphHour]);
        } else {
          reject([400, "Cannot get Hour Market Data"]);
        }
      });
    });
  });

  // Dashboard Project
  // Project Overview
  mock.onGet(url.GET_ALLPROJECT_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allProjectData) {
          // Passing fake JSON data as response
          resolve([200, allProjectData]);
        } else {
          reject([400, "Cannot get All Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHPROJECT_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthProjectData) {
          // Passing fake JSON data as response
          resolve([200, monthProjectData]);
        } else {
          reject([400, "Cannot get Month Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HALFYEARPROJECT_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (halfyearProjectData) {
          // Passing fake JSON data as response
          resolve([200, halfyearProjectData]);
        } else {
          reject([400, "Cannot get Half Year Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARPROJECT_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (yearProjectData) {
          // Passing fake JSON data as response
          resolve([200, yearProjectData]);
        } else {
          reject([400, "Cannot get Year Chart Data"]);
        }
      });
    });
  });

  // Project Status
  mock.onGet(url.GET_ALLPROJECTSTATUS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allTimeData) {
          // Passing fake JSON data as response
          resolve([200, allTimeData]);
        } else {
          reject([400, "Cannot get All Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_WEEKPROJECTSTATUS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastWeekData) {
          // Passing fake JSON data as response
          resolve([200, lastWeekData]);
        } else {
          reject([400, "Cannot get Last Week Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHPROJECTSTATUS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastMonthData) {
          // Passing fake JSON data as response
          resolve([200, lastMonthData]);
        } else {
          reject([400, "Cannot get Last Month Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_QUARTERPROJECTSTATUS_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (lastquarterData) {
          // Passing fake JSON data as response
          resolve([200, lastquarterData]);
        } else {
          reject([400, "Cannot get Last Quarter Chart Data"]);
        }
      });
    });
  });

  // Dashboard NFT
  // Marketplace
  mock.onGet(url.GET_ALLMARKETPLACE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allMarketplaceData) {
          // Passing fake JSON data as response
          resolve([200, allMarketplaceData]);
        } else {
          reject([400, "Cannot get All Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_MONTHMARKETPLACE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (monthMarketplaceData) {
          // Passing fake JSON data as response
          resolve([200, monthMarketplaceData]);
        } else {
          reject([400, "Cannot get Month Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_HALFYEARMARKETPLACE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (halfyearMarketplaceData) {
          // Passing fake JSON data as response
          resolve([200, halfyearMarketplaceData]);
        } else {
          reject([400, "Cannot get Half Year Chart Data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_YEARMARKETPLACE_DATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (yearMarketplaceData) {
          // Passing fake JSON data as response
          resolve([200, yearMarketplaceData]);
        } else {
          reject([400, "Cannot get Year Chart Data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_PROJECT).reply((project) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (project && project.data) {
          // Passing fake JSON data as response
          resolve([200, project.data]);
        } else {
          reject([400, "Cannot add project"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_PROJECT).reply((project) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (project && project.data) {
          // Passing fake JSON data as response
          resolve([200, project.data]);
        } else {
          reject([400, "Cannot update project"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_PROJECT).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.project]);
        } else {
          reject([400, "Cannot delete event"]);
        }
      });
    });
  });

  mock.onGet(url.GET_TEAMDATA).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (team) {
          // Passing fake JSON data as response
          resolve([200, team]);
        } else {
          reject([400, "Cannot get team data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_TEAMDATA).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.team]);
        } else {
          reject([400, "Cannot delete team data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_TEAMDATA).reply((team) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (team && team.data) {
          // Passing fake JSON data as response
          resolve([200, team.data]);
        } else {
          reject([400, "Cannot add team data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_TEAMDATA).reply((team) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (team && team.data) {
          // Passing fake JSON data as response
          resolve([200, team.data]);
        } else {
          reject([400, "Cannot update team data"]);
        }
      });
    });
  });


      // Ecommerce

  // Product
  mock.onGet(url.GET_PRODUCTS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (productsData) {
          // Passing fake JSON data as response
          resolve([200, productsData]);
        } else {
          reject([400, "Cannot get order Data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_PRODUCT).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot add event"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_PRODUCT).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_PRODUCT).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });


  mock.onDelete(url.DELETE_PRODUCT).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          resolve([200, config.headers.data]);
        } else {
          reject([400, "Cannot delete event"]);
        }
      });
    });
  });

  //ecommerce / orders
  mock.onGet(url.GET_ORDERS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (orders) {
          // Passing fake JSON data as response
          resolve([200, orders]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_ORDER).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_ORDER).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_ORDER).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_ORDER).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

  // Ecommerce / Customer
  mock.onGet(url.GET_CUSTOMERS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (customerList) {
          // Passing fake JSON data as response
          resolve([200, customerList]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_CUSTOMER).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_CUSTOMER).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_CUSTOMER).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_CUSTOMER).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  }); 
  //  Tasks List
  mock.onGet(url.GET_TASK_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (allTask) {
          // Passing fake JSON data as response
          resolve([200, allTask]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_TASK).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_TASK).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_TASK).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_TASK).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  }); 

    // Kanban Board
    mock.onGet(url.GET_TASKS).reply(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (tasklist) {
            // Passing fake JSON data as response
            resolve([200, tasklist]);
          } else {
            reject([400, "Cannot get tasks"]);
          }
        });
      });
    });
  
    mock.onPost(url.ADD_TASKS).reply(user => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (user && user.data) {
            // Passing fake JSON data as response
            resolve([200, user.data]);
          } else {
            reject([400, "Cannot add user"]);
          }
        });
      });
    });
  
    mock.onPut(url.UPDATE_TASKS).reply((user) => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (user && user.data) {
            // Passing fake JSON data as response
            resolve([200, user.data]);
          } else {
            reject([400, "Cannot update user"]);
          }
        });
      });
    });
  
    mock.onDelete(url.DELETE_TASKS).reply(config => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (config && config.headers) {
            // Passing fake JSON data as response
            resolve([200, config.headers.card]);
          } else {
            reject([400, "Cannot delete users"]);
          }
        });
      });
    });

  // Support Ticket

  mock.onGet(url.GET_TICKETS_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (ticketsTable) {
          // Passing fake JSON data as response
          resolve([200, ticketsTable]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_TICKET).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_TICKET).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_TICKET).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_TICKET).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  }); 

   // candidate list
   mock.onGet(url.GET_CANDIDATE).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (jobCandidates) {
          // Passing fake JSON data as response
          resolve([200, jobCandidates]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_CANDIDATE).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_CANDIDATE).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_CANDIDATE).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  // Grid

  mock.onGet(url.GET_CANDIDATE_GRID).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (jobCandidates) {
          // Passing fake JSON data as response
          resolve([200, jobCandidates]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_CANDIDATE_GRID).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  // category
  mock.onGet(url.GET_CATEGORY_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (jobCategories) {
          // Passing fake JSON data as response
          resolve([200, jobCategories]);
        } else {
          reject([400, "Cannot get Application Data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_CATEGORY_LIST).reply((project) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (project && project.data) {
          // Passing fake JSON data as response
          resolve([200, project.data]);
        } else {
          reject([400, "Cannot add Project data"]);
        }
      });
    });
  });

   // Crm Contact
   mock.onGet(url.GET_CONTACTS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (crmcontacts) {
          // Passing fake JSON data as response
          resolve([200, crmcontacts]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_CONTACT).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_CONTACT).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_CONTACT).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_CONTACT).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

   // Crm Companies
   mock.onGet(url.GET_COMPANIES).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (companies) {
          // Passing fake JSON data as response
          resolve([200, companies]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_COMPANIES).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_COMPANIES).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_COMPANIES).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_COMPANIES).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

   // Crm Leads
   mock.onGet(url.GET_LEADS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (leads) {
          // Passing fake JSON data as response
          resolve([200, leads]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_LEAD).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_LEAD).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_LEAD).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  mock.onPatch(url.UPDATE_LEAD).reply((event: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (event && event.data) {
          // Passing fake JSON data as response
          resolve([200, event.data]);
        } else {
          reject([400, "Cannot update event"]);
        }
      });
    });
  });

  // File Manager
  // Folder
  mock.onGet(url.GET_FOLDERS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (folderList) {
          // Passing fake JSON data as response
          resolve([200, folderList]);
        } else {
          reject([400, "Cannot get folder data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_FOLDER).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.folder]);
        } else {
          reject([400, "Cannot delete folder data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_FOLDER).reply((folder) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (folder && folder.data) {
          // Passing fake JSON data as response
          resolve([200, folder.data]);
        } else {
          reject([400, "Cannot add folder data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_FOLDER).reply((folder) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (folder && folder.data) {
          // Passing fake JSON data as response
          resolve([200, folder.data]);
        } else {
          reject([400, "Cannot update folder data"]);
        }
      });
    });
  });

  // File
  mock.onGet(url.GET_FILES).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (recentFile) {
          // Passing fake JSON data as response
          resolve([200, recentFile]);
        } else {
          reject([400, "Cannot get file data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_FILE).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.file]);
        } else {
          reject([400, "Cannot delete file data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_FILE).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot add file data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_FILE).reply((file) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (file && file.data) {
          // Passing fake JSON data as response
          resolve([200, file.data]);
        } else {
          reject([400, "Cannot update file data"]);
        }
      });
    });
  });

  // To do
  mock.onGet(url.GET_TODOS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todoTaskList) {
          // Passing fake JSON data as response
          resolve([200, todoTaskList]);
        } else {
          reject([400, "Cannot get To do data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_TODO).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.todo]);
        } else {
          reject([400, "Cannot delete To do data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_TODO).reply((todo) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todo && todo.data) {
          // Passing fake JSON data as response
          resolve([200, todo.data]);
        } else {
          reject([400, "Cannot add To do data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_TODO).reply((todo) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todo && todo.data) {
          // Passing fake JSON data as response
          resolve([200, todo.data]);
        } else {
          reject([400, "Cannot update To do data"]);
        }
      });
    });
  });

  mock.onGet(url.GET_PROJECTS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (todoCollapse) {
          // Passing fake JSON data as response
          resolve([200, todoCollapse]);
        } else {
          reject([400, "Cannot get Project data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_TODO_PROJECT).reply((project) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (project && project.data) {
          // Passing fake JSON data as response
          resolve([200, project.data]);
        } else {
          reject([400, "Cannot add Project data"]);
        }
      });
    });
  });

  //JOBS
  mock.onGet(url.GET_APPLICATION_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (jobApplication) {
          // Passing fake JSON data as response
          resolve([200, jobApplication]);
        } else {
          reject([400, "Cannot get Application Data"]);
        }
      });
    });
  });

  mock.onPost(url.ADD_NEW_APPLICATION_LIST).reply((job) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (job && job.data) {
          // Passing fake JSON data as response
          resolve([200, job.data]);
        } else {
          reject([400, "Cannot add Job Application data"]);
        }
      });
    });
  });

  mock.onPut(url.UPDATE_APPLICATION_LIST).reply((job) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (job && job.data) {
          // Passing fake JSON data as response
          resolve([200, job.data]);
        } else {
          reject([400, "Cannot update Job Application data"]);
        }
      });
    });
  });

  mock.onDelete(url.DELETE_APPLICATION_LIST).reply((config) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          // Passing fake JSON data as response
          resolve([200, config.headers.job]);
        } else {
          reject([400, "Cannot delete Job Application data"]);
        }
      });
    });
  });

   // Invoice
   mock.onDelete(url.DELETE_INVOICE).reply((config: any) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (config && config.headers) {
          resolve([200, config.headers.invoice]);
        } else {
          reject([400, "Cannot delete event"]);
        }
      });
    });
  });

  // Device
  mock.onGet(url.GET_DEVICES_KPIS).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (devicesKpis) resolve([200, devicesKpis]);
        else reject([400, "Cannot get Devices KPIs"]);
      });
    });
  });

  mock.onGet(url.GET_DEVICES_LIST).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (devicesMockData) resolve([200, devicesMockData]);
        else reject([400, "Cannot get devices list"]);
      }, 500);
    });
  });


// Mock para los datos del grÃ¡fico de dispositivos
mock.onGet(new RegExp(url.GET_DEVICES_CHART_DATA)).reply((config) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        // Los parÃ¡metros (year, month) se leen de 'config.params'
        const { year, month } = config.params;

        if (!year || !month) {
          return reject([400, "Year and month parameters are required"]);
        }
        
        // Se crea el prefijo para buscar en los datos simulados
        const monthString = String(month).padStart(2, '0');
        const searchPrefix = `${year}-${monthString}`;
        
        // Se filtran los datos para devolver solo los del mes y aÃ±o solicitados
        const data = Array.isArray(devicesChartData)
          ? devicesChartData.filter(item => item.date.startsWith(searchPrefix))
          : [];
        
        resolve([200, data]);

      } catch (error) {
        reject([500, "Failed to process chart data request"]);
      }
    }, 300); // PequeÃ±o delay para simular una llamada de red
  });
});


  

  //API Key
  mock.onGet(url.GET_API_KEY).reply(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (apiKey) {
          // Passing fake JSON data as response
          resolve([200, apiKey]);
        } else {
          reject([400, "Cannot get API Key Data"]);
        }
      });
    });
  });

};

export default fakeBackend;

---- File: src\helpers\fakebackend_helper.ts ----
import { APIClient } from "./api_helper";

import * as url from "./url_helper";

const api = new APIClient();

// Gets the logged in user data from local session
export const getLoggedInUser = () => {
  const user = localStorage.getItem("user");
  if (user) return JSON.parse(user);
  return null;
};

// //is user is logged in
export const isUserAuthenticated = () => {
  return getLoggedInUser() !== null;
};

// Register Method
export const postFakeRegister = (data : any) => api.create(url.POST_FAKE_REGISTER, data);

// Login Method
export const postFakeLogin = (data : any) => api.create(url.POST_FAKE_LOGIN, data);

// postForgetPwd
export const postFakeForgetPwd = (data : any) => api.create(url.POST_FAKE_PASSWORD_FORGET, data);

// Edit profile
export const postJwtProfile = (data : any) => api.create(url.POST_EDIT_JWT_PROFILE, data);

export const postFakeProfile = (data : any) => api.update(url.POST_EDIT_PROFILE + '/' + data.idx, data);

// Register Method
export const postJwtRegister = (url : string, data  :any) => {
  return api.create(url, data)
    .catch(err => {
      var message;
      if (err.response && err.response.status) {
        switch (err.response.status) {
          case 404:
            message = "Sorry! the page you are looking for could not be found";
            break;
          case 500:
            message = "Sorry! something went wrong, please contact our support team";
            break;
          case 401:
            message = "Invalid credentials";
            break;
          default:
            message = err[1];
            break;
        }
      }
      throw message;
    });
};

// Login Method
export const postJwtLogin = (data : any) => api.create(url.POST_FAKE_JWT_LOGIN, data);

// postForgetPwd
export const postJwtForgetPwd = (data : any) => api.create(url.POST_FAKE_JWT_PASSWORD_FORGET, data);

// postSocialLogin
export const postSocialLogin = (data : any) => api.create(url.SOCIAL_LOGIN, data);

// Calendar
// get Events
export const getEvents = () => api.get(url.GET_EVENTS);

// get Events
export const getCategories = () => api.get(url.GET_CATEGORIES);

// get Upcomming Events
export const getUpCommingEvent = () => api.get(url.GET_UPCOMMINGEVENT);

// add Events
export const addNewEvent = (event : any) => api.create(url.ADD_NEW_EVENT, event);

// update Event
export const updateEvent = (event : any) => api.put(url.UPDATE_EVENT, event);

// delete Event
export const deleteEvent = (event : any) => api.delete(url.DELETE_EVENT, { headers: { event } });

// Chat
// get Contact
export const getDirectContact = () => api.get(url.GET_DIRECT_CONTACT);

// get Messages
export const getMessages = (roomId : any) => api.get(`${url.GET_MESSAGES}/${roomId}`, { params: { roomId } });

// add Message
export const addMessage = (message : any) => api.create(url.ADD_MESSAGE, message);

// add Message
export const deleteMessage = (message : any) => api.delete(url.DELETE_MESSAGE, { headers: { message } });

// get Channels
export const getChannels = () => api.get(url.GET_CHANNELS);

// MailBox
//get Mail
export const getMailDetails = () => api.get(url.GET_MAIL_DETAILS);

// delete Mail
export const deleteMail = (forId: any) => api.delete(url.DELETE_MAIL, { headers: { forId } });

// unread Mail
export const unreadMail = (forId: any) => api.delete(url.UNREAD_MAIL, { headers: { forId } });

// star Mail
export const staredMail = (forId: any) => api.delete(url.STARED_MAIL, { headers: { forId } });

// label Mail
export const labelMail = (forId: any) => api.delete(url.LABEL_MAIL, { headers: { forId } });

// trash Mail
export const trashMail = (forId: any) => api.delete(url.TRASH_MAIL, { headers: { forId } });

// Ecommerce
// get Products
export const getProducts = () => api.get(url.GET_PRODUCTS);

// delete Product
export const deleteProducts = (product : any) => api.delete(url.DELETE_PRODUCT, { headers: { product } } );  

// add Products
export const addNewProduct = (product : any) => api.create(url.ADD_NEW_PRODUCT, product);
// update Products
export const updateProduct = (product : any) => api.update(url.UPDATE_PRODUCT, product ); 

// get Orders
export const getOrders = () => api.get(url.GET_ORDERS);

// add Order
export const addNewOrder = (order : any) => api.create(url.ADD_NEW_ORDER, order);

// update Order
export const updateOrder = (order : any) => api.update(url.UPDATE_ORDER, order);

// delete Order
export const deleteOrder = (order : any) => api.delete(url.DELETE_ORDER , { headers: { order } });

// get Customers
export const getCustomers = () => api.get(url.GET_CUSTOMERS);

// add Customers
export const addNewCustomer = (customer : any) => api.create(url.ADD_NEW_CUSTOMER, customer);

// update Customers
export const updateCustomer = (customer : any) => api.update(url.UPDATE_CUSTOMER, customer);

// delete Customers
export const deleteCustomer = (customer : any) => api.delete(url.DELETE_CUSTOMER, { headers: { customer } });

// get Sellers
export const getSellers = () => api.get(url.GET_SELLERS);

// Project
// get Project list 
export const getProjectList = () => api.get(url.GET_PROJECT_LIST);

// Tasks
// get Task
export const getTaskList = () => api.get(url.GET_TASK_LIST);

// add Task
export const addNewTask = (task : any) => api.create(url.ADD_NEW_TASK, task);

// update Task
export const updateTask = (task : any) => api.update(url.UPDATE_TASK, task);

// delete Task
export const deleteTask = (task : any) => api.delete(url.DELETE_TASK, { headers: { task }});

// Kanban Board
export const getTasks = () => api.get(url.GET_TASKS);
export const addNewTasks = (card: any) => api.create(url.ADD_TASKS, card)
export const updateTasks = (card: any) => api.put(url.UPDATE_TASKS, card)
export const deleteTasks = (card: any) => api.delete(url.DELETE_TASKS, { headers: {card} })

// CRM
// get Contacts
export const getContacts = () => api.get(url.GET_CONTACTS);

// add Contact
export const addNewContact = (contact : any) => api.create(url.ADD_NEW_CONTACT, contact);

// update Contact
export const updateContact = (contact : any) => api.update(url.UPDATE_CONTACT, contact);

// delete Contact
export const deleteContact = (contact : any) => api.delete(url.DELETE_CONTACT, { headers: { contact }});

// get Companies
export const getCompanies = () => api.get(url.GET_COMPANIES);

// add Companies
export const addNewCompanies = (company : any) => api.create(url.ADD_NEW_COMPANIES, company);

// update Companies
export const updateCompanies = (company : any) => api.update(url.UPDATE_COMPANIES, company);

// delete Companies
export const deleteCompanies = (company : any) => api.delete(url.DELETE_COMPANIES, { headers: {company}});

// get Deals
export const getDeals = () => api.get(url.GET_DEALS);

// get Leads
export const getLeads = () => api.get(url.GET_LEADS);

// add Lead
export const addNewLead = (lead : any) => api.create(url.ADD_NEW_LEAD, lead);

// update Lead
export const updateLead = (lead : any) => api.update(url.UPDATE_LEAD, lead);

// delete Lead
export const deleteLead = (lead : any) => api.delete(url.DELETE_LEAD, { headers: {lead}});

// Crypto
// Transation
export const getTransationList = () => api.get(url.GET_TRANSACTION_LIST);

// Order List
export const getOrderList = () => api.get(url.GET_ORDRER_LIST);

// Invoice
//get Invoice
export const getInvoices = () => api.get(url.GET_INVOICES);

// add Invoice
export const addNewInvoice = (invoice : any) => api.create(url.ADD_NEW_INVOICE, invoice);

// update Invoice
export const updateInvoice = (invoice : any) => api.update(url.UPDATE_INVOICE + '/' + invoice._id, invoice);

// delete Invoice
export const deleteInvoice = (invoice : any) => api.delete(url.DELETE_INVOICE + '/' + invoice);

/**
 * --------------------------------------------------------------------------
 * NUEVAS FUNCIONES PARA EL MÃ“DULO DE DEVICES
 * --------------------------------------------------------------------------
 */

// **Devices**
// KPIs de devices
export const getDevicesKpis = () => api.get(url.GET_DEVICES_KPIS);

export const getDevicesList = () => api.get(url.GET_DEVICES_LIST);

export const getDevicesChartData = (params: { year: number, month: number }) => 
    api.get(url.GET_DEVICES_CHART_DATA, { params });

// Support Tickets 
// Tickets
export const getTicketsList = () => api.get(url.GET_TICKETS_LIST);

// add Tickets 
export const addNewTicket = (ticket : any) => api.create(url.ADD_NEW_TICKET, ticket);

// update Tickets 
export const updateTicket = (ticket : any) => api.update(url.UPDATE_TICKET, ticket);

// delete Tickets 
export const deleteTicket = (ticket : any) => api.delete(url.DELETE_TICKET, { headers: {ticket}});

// Dashboard Analytics

// Sessions by Countries
export const getAllData = () => api.get(url.GET_ALL_DATA);
export const getHalfYearlyData = () => api.get(url.GET_HALFYEARLY_DATA);
export const getMonthlyData = () => api.get(url.GET_MONTHLY_DATA);

// Audiences Metrics
export const getAllAudiencesMetricsData = () => api.get(url.GET_ALLAUDIENCESMETRICS_DATA);
export const getMonthlyAudiencesMetricsData = () => api.get(url.GET_MONTHLYAUDIENCESMETRICS_DATA);
export const getHalfYearlyAudiencesMetricsData = () => api.get(url.GET_HALFYEARLYAUDIENCESMETRICS_DATA);
export const getYearlyAudiencesMetricsData = () => api.get(url.GET_YEARLYAUDIENCESMETRICS_DATA);

// Users by Device
export const getTodayDeviceData = () => api.get(url.GET_TODAYDEVICE_DATA);
export const getLastWeekDeviceData = () => api.get(url.GET_LASTWEEKDEVICE_DATA);
export const getLastMonthDeviceData = () => api.get(url.GET_LASTMONTHDEVICE_DATA);
export const getCurrentYearDeviceData = () => api.get(url.GET_CURRENTYEARDEVICE_DATA);

// Audiences Sessions by Country
export const getTodaySessionData = () => api.get(url.GET_TODAYSESSION_DATA);
export const getLastWeekSessionData = () => api.get(url.GET_LASTWEEKSESSION_DATA);
export const getLastMonthSessionData = () => api.get(url.GET_LASTMONTHSESSION_DATA);
export const getCurrentYearSessionData = () => api.get(url.GET_CURRENTYEARSESSION_DATA);

// Dashboard CRM

// Balance Overview
export const getTodayBalanceData = () => api.get(url.GET_TODAYBALANCE_DATA);
export const getLastWeekBalanceData = () => api.get(url.GET_LASTWEEKBALANCE_DATA);
export const getLastMonthBalanceData = () => api.get(url.GET_LASTMONTHBALANCE_DATA);
export const getCurrentYearBalanceData = () => api.get(url.GET_CURRENTYEARBALANCE_DATA);

// Dial Type
export const getTodayDealData = () => api.get(url.GET_TODAYDEAL_DATA);
export const getWeeklyDealData = () => api.get(url.GET_WEEKLYDEAL_DATA);
export const getMonthlyDealData = () => api.get(url.GET_MONTHLYDEAL_DATA);
export const getYearlyDealData = () => api.get(url.GET_YEARLYDEAL_DATA);

// Sales Forecast
export const getOctSalesData = () => api.get(url.GET_OCTSALES_DATA);
export const getNovSalesData = () => api.get(url.GET_NOVSALES_DATA);
export const getDecSalesData = () => api.get(url.GET_DECSALES_DATA);
export const getJanSalesData = () => api.get(url.GET_JANSALES_DATA);

// Dashboard Ecommerce
// Revenue
export const getAllRevenueData = () => api.get(url.GET_ALLREVENUE_DATA);
export const getMonthRevenueData = () => api.get(url.GET_MONTHREVENUE_DATA);
export const getHalfYearRevenueData = () => api.get(url.GET_HALFYEARREVENUE_DATA);
export const getYearRevenueData = () => api.get(url.GET_YEARREVENUE_DATA);


// Dashboard Crypto
// Portfolio
export const getBtcPortfolioData = () => api.get(url.GET_BTCPORTFOLIO_DATA);
export const getUsdPortfolioData = () => api.get(url.GET_USDPORTFOLIO_DATA);
export const getEuroPortfolioData = () => api.get(url.GET_EUROPORTFOLIO_DATA);

// Market Graph
export const getAllMarketData = () => api.get(url.GET_ALLMARKETDATA_DATA);
export const getYearMarketData = () => api.get(url.GET_YEARMARKET_DATA);
export const getMonthMarketData = () => api.get(url.GET_MONTHMARKET_DATA);
export const getWeekMarketData = () => api.get(url.GET_WEEKMARKET_DATA);
export const getHourMarketData = () => api.get(url.GET_HOURMARKET_DATA);

// Dashboard Project
// Project Overview
export const getAllProjectData = () => api.get(url.GET_ALLPROJECT_DATA);
export const getMonthProjectData = () => api.get(url.GET_MONTHPROJECT_DATA);
export const gethalfYearProjectData = () => api.get(url.GET_HALFYEARPROJECT_DATA);
export const getYearProjectData = () => api.get(url.GET_YEARPROJECT_DATA);

// Project Status
export const getAllProjectStatusData = () => api.get(url.GET_ALLPROJECTSTATUS_DATA);
export const getWeekProjectStatusData = () => api.get(url.GET_WEEKPROJECTSTATUS_DATA);
export const getMonthProjectStatusData = () => api.get(url.GET_MONTHPROJECTSTATUS_DATA);
export const getQuarterProjectStatusData = () => api.get(url.GET_QUARTERPROJECTSTATUS_DATA);

// dashboard job
export const getApplicationsStatistic = (roomId : any) => api.get(url.GET_JOBAPPLICATIONSTATISTIC, roomId);

// Dashboard NFT
// Marketplace
export const getAllMarketplaceData = () => api.get(url.GET_ALLMARKETPLACE_DATA);
export const getMonthMarketplaceData = () => api.get(url.GET_MONTHMARKETPLACE_DATA);
export const gethalfYearMarketplaceData = () => api.get(url.GET_HALFYEARMARKETPLACE_DATA);
export const getYearMarketplaceData = () => api.get(url.GET_YEARMARKETPLACE_DATA);

// Project
export const addProjectList = (project : any) => api.create(url.ADD_NEW_PROJECT, project);
export const updateProjectList = (project : any) => api.put(url.UPDATE_PROJECT, project);
export const deleteProjectList = (project : any) => api.delete(url.DELETE_PROJECT, { headers: { project } });

// Pages > Team
export const getTeamData = () => api.get(url.GET_TEAMDATA);
export const deleteTeamData = (team : any) => api.delete(url.DELETE_TEAMDATA, { headers: { team } });
export const addTeamData = (team : any) => api.create(url.ADD_NEW_TEAMDATA, team);
export const updateTeamData = (team : any) => api.put(url.UPDATE_TEAMDATA, team);

// File Manager

// Folder
export const getFolders = () => api.get(url.GET_FOLDERS);
export const deleteFolder = (folder : any) => api.delete(url.DELETE_FOLDER, { headers: { folder } });
export const addNewFolder = (folder : any) => api.create(url.ADD_NEW_FOLDER, folder);
export const updateFolder = (folder : any) => api.put(url.UPDATE_FOLDER, folder);

// File
export const getFiles = () => api.get(url.GET_FILES);
export const deleteFile = (file : any) => api.delete(url.DELETE_FILE, { headers: { file } });
export const addNewFile = (file : any) => api.create(url.ADD_NEW_FILE, file);
export const updateFile = (file : any) => api.put(url.UPDATE_FILE, file);

// To Do
export const getTodos = () => api.get(url.GET_TODOS);
export const deleteTodo = (todo : any) => api.delete(url.DELETE_TODO, { headers: { todo } });
export const addNewTodo = (todo : any) => api.create(url.ADD_NEW_TODO, todo);
export const updateTodo = (todo : any) => api.put(url.UPDATE_TODO, todo);

// To do Project
export const getProjects = () => api.get(url.GET_PROJECTS);
export const addNewProject = (project : any) => api.create(url.ADD_NEW_TODO_PROJECT, project);

//API Key
export const getAPIKey = () => api.get(url.GET_API_KEY);

//Job Application
export const getJobApplicationList = () => api.get(url.GET_APPLICATION_LIST);
export const addNewJobApplicationList = (job: any) => api.create(url.ADD_NEW_APPLICATION_LIST, job);
export const updateJobApplicationList = (job: any) => api.put(url.UPDATE_APPLICATION_LIST, job);
export const deleteJobApplicationList = (job: any) => api.delete(url.DELETE_APPLICATION_LIST, { headers: { job } });

// candidate list
export const getJobCandidateList = () => api.get(url.GET_CANDIDATE, '');
export const addJobCandidate = (candidate : any) => api.create(url.ADD_NEW_CANDIDATE, candidate);
export const updateJobCandidate = (candidate : any) => api.update(url.UPDATE_CANDIDATE, candidate);
export const deleteJobCandidate = (candidate : any) => api.delete(url.DELETE_CANDIDATE, { headers: {candidate} });

// category list
export const getcategoryList = () => api.get(url.GET_CATEGORY_LIST);
export const addcategoryList = (category : any) => api.create(url.ADD_CATEGORY_LIST, category);

// grid
export const getCandidateGrid = () => api.get(url.GET_CANDIDATE_GRID);
export const addCandidateGrid = (category : any) => api.create(url.ADD_CANDIDATE_GRID, category);

---- File: src\helpers\url_helper.ts ----
//REGISTER
export const POST_FAKE_REGISTER = "/auth/signup";

//LOGIN
export const POST_FAKE_LOGIN = "/auth/signin";
export const POST_FAKE_JWT_LOGIN = "/post-jwt-login";
export const POST_FAKE_PASSWORD_FORGET = "/auth/forgot-password";
export const POST_FAKE_JWT_PASSWORD_FORGET = "/jwt-forget-pwd";
export const SOCIAL_LOGIN = "/social-login";

//PROFILE
export const POST_EDIT_JWT_PROFILE = "/post-jwt-profile";
export const POST_EDIT_PROFILE = "/user";

// Calendar
export const GET_EVENTS = "/events";
export const GET_CATEGORIES = "/categories";
export const GET_UPCOMMINGEVENT = "/upcommingevents";
export const ADD_NEW_EVENT = "/add/event";
export const UPDATE_EVENT = "/update/event";
export const DELETE_EVENT = "/delete/event";

// Chat
export const GET_DIRECT_CONTACT = "/chat";
export const GET_MESSAGES = "/messages";
export const ADD_MESSAGE = "add/message";
export const GET_CHANNELS = "/channels";
export const DELETE_MESSAGE = "delete/message";

//Mailbox
export const GET_MAIL_DETAILS = "/mail";
export const DELETE_MAIL = "/delete/mail";
export const UNREAD_MAIL = "/unread/mail";
export const STARED_MAIL = "/stared/mail";
export const LABEL_MAIL = "/label/mail";
export const TRASH_MAIL = "/trash/mail";

// Ecommerce
// Product
export const GET_PRODUCTS = "/apps/product";
export const DELETE_PRODUCT = "/apps/product";
export const ADD_NEW_PRODUCT = "/apps/product";
export const UPDATE_PRODUCT = "/apps/product";

// Orders
export const GET_ORDERS = "/apps/order";
export const ADD_NEW_ORDER = "/apps/order";
export const UPDATE_ORDER = "/apps/order";
export const DELETE_ORDER = "/apps/order";

// Customers
export const GET_CUSTOMERS = "/apps/customer";
export const ADD_NEW_CUSTOMER = "/apps/customer";
export const UPDATE_CUSTOMER = "/apps/customer";
export const DELETE_CUSTOMER = "/apps/customer";

// Sellers
export const GET_SELLERS = "/sellers";

// Project list
export const GET_PROJECT_LIST = "/project/list";

// Task
export const GET_TASK_LIST = "/apps/task";
export const ADD_NEW_TASK = "/apps/task";
export const UPDATE_TASK = "/apps/task";
export const DELETE_TASK = "/apps/task";

// kanban
export const GET_TASKS = "/apps/tasks";
export const ADD_TASKS = "/add/tasks";
export const UPDATE_TASKS = "/update/tasks";
export const DELETE_TASKS = "/delete/tasks";

// CRM
// Conatct
export const GET_CONTACTS = "/apps/contact";
export const ADD_NEW_CONTACT = "/apps/contact";
export const UPDATE_CONTACT = "/apps/contact";
export const DELETE_CONTACT = "/apps/contact";

// Companies
export const GET_COMPANIES = "/apps/company";
export const ADD_NEW_COMPANIES = "/apps/company";
export const UPDATE_COMPANIES = "/apps/company";
export const DELETE_COMPANIES = "/apps/company";

// Lead
export const GET_LEADS = "/apps/lead";
export const ADD_NEW_LEAD = "/apps/lead";
export const UPDATE_LEAD = "/apps/lead";
export const DELETE_LEAD = "/apps/lead";

// Deals
export const GET_DEALS = "/deals";

// Crypto
export const GET_TRANSACTION_LIST = "/transaction-list";
export const GET_ORDRER_LIST = "/order-list";

// Invoice
export const GET_INVOICES = "/apps/invoice";
export const ADD_NEW_INVOICE = "/apps/invoice";
export const UPDATE_INVOICE = "/apps/invoice";
export const DELETE_INVOICE = "/apps/invoice";


// Devices
export const GET_DEVICES = "/apps/device";
export const GET_DEVICES_KPIS = "/apps/device-kpis";
export const GET_DEVICES_LIST = "/apps/devices-list";
export const GET_DEVICES_CHART_DATA = "/apps/devices-chart-data";
export const ADD_NEW_DEVICE = "/apps/device";
export const UPDATE_DEVICE = "/apps/device";
export const DELETE_DEVICE = "/apps/device";





// TicketsList
export const GET_TICKETS_LIST = "/apps/ticket";
export const ADD_NEW_TICKET = "/apps/ticket";
export const UPDATE_TICKET = "/apps/ticket";
export const DELETE_TICKET = "/apps/ticket";

// Dashboard Analytics

// Sessions by Countries
export const GET_ALL_DATA = "/all-data";
export const GET_HALFYEARLY_DATA = "/halfyearly-data";
export const GET_MONTHLY_DATA = "/monthly-data";

// Audiences Metrics
export const GET_ALLAUDIENCESMETRICS_DATA = "/allAudiencesMetrics-data";
export const GET_MONTHLYAUDIENCESMETRICS_DATA = "/monthlyAudiencesMetrics-data";
export const GET_HALFYEARLYAUDIENCESMETRICS_DATA = "/halfyearlyAudiencesMetrics-data";
export const GET_YEARLYAUDIENCESMETRICS_DATA = "/yearlyAudiencesMetrics-data";

// Users by Device
export const GET_TODAYDEVICE_DATA = "/todayDevice-data";
export const GET_LASTWEEKDEVICE_DATA = "/lastWeekDevice-data";
export const GET_LASTMONTHDEVICE_DATA = "/lastMonthDevice-data";
export const GET_CURRENTYEARDEVICE_DATA = "/currentYearDevice-data";

// Audiences Sessions by Country
export const GET_TODAYSESSION_DATA = "/todaySession-data";
export const GET_LASTWEEKSESSION_DATA = "/lastWeekSession-data";
export const GET_LASTMONTHSESSION_DATA = "/lastMonthSession-data";
export const GET_CURRENTYEARSESSION_DATA = "/currentYearSession-data";

// Dashboard CRM

// Balance Overview
export const GET_TODAYBALANCE_DATA = "/todayBalance-data";
export const GET_LASTWEEKBALANCE_DATA = "/lastWeekBalance-data";
export const GET_LASTMONTHBALANCE_DATA = "/lastMonthBalance-data";
export const GET_CURRENTYEARBALANCE_DATA = "/currentYearBalance-data";

// Deal type
export const GET_TODAYDEAL_DATA = "/todayDeal-data";
export const GET_WEEKLYDEAL_DATA = "/weeklyDeal-data";
export const GET_MONTHLYDEAL_DATA = "/monthlyDeal-data";
export const GET_YEARLYDEAL_DATA = "/yearlyDeal-data";

// Sales Forecast

export const GET_OCTSALES_DATA = "/octSales-data";
export const GET_NOVSALES_DATA = "/novSales-data";
export const GET_DECSALES_DATA = "/decSales-data";
export const GET_JANSALES_DATA = "/janSales-data";

// Dashboard Ecommerce
// Revenue
export const GET_ALLREVENUE_DATA = "/allRevenue-data";
export const GET_MONTHREVENUE_DATA = "/monthRevenue-data";
export const GET_HALFYEARREVENUE_DATA = "/halfYearRevenue-data";
export const GET_YEARREVENUE_DATA = "/yearRevenue-data";

// Dashboard Job
// Applications Statistic
export const GET_APPLICTION_DATA = "/applictionStatistic-data";

// Dashboard Crypto
// Portfolio
export const GET_BTCPORTFOLIO_DATA = "/btcPortfolio-data";
export const GET_USDPORTFOLIO_DATA = "/usdPortfolio-data";
export const GET_EUROPORTFOLIO_DATA = "/euroPortfolio-data";

// Market Graph
export const GET_ALLMARKETDATA_DATA = "/allMarket-data";
export const GET_YEARMARKET_DATA = "/yearMarket-data";
export const GET_MONTHMARKET_DATA = "/monthMarket-data";
export const GET_WEEKMARKET_DATA = "/weekMarket-data";
export const GET_HOURMARKET_DATA = "/hourMarket-data";

// Dashboard Crypto
// Project Overview
export const GET_ALLPROJECT_DATA = "/allProject-data";
export const GET_MONTHPROJECT_DATA = "/monthProject-data";
export const GET_HALFYEARPROJECT_DATA = "/halfYearProject-data";
export const GET_YEARPROJECT_DATA = "/yearProject-data";

// Project Status
export const GET_ALLPROJECTSTATUS_DATA = "/allProjectStatus-data";
export const GET_WEEKPROJECTSTATUS_DATA = "/weekProjectStatus-data";
export const GET_MONTHPROJECTSTATUS_DATA = "/monthProjectStatus-data";
export const GET_QUARTERPROJECTSTATUS_DATA = "/quarterProjectStatus-data";

// job
export const GET_JOBAPPLICATIONSTATISTIC = "/applicationstatistic"

// Dashboard NFT
// Marketplace
export const GET_ALLMARKETPLACE_DATA = "/allMarketplace-data";
export const GET_MONTHMARKETPLACE_DATA = "/monthMarketplace-data";
export const GET_HALFYEARMARKETPLACE_DATA = "/halfYearMarketplace-data";
export const GET_YEARMARKETPLACE_DATA = "/yearMarketplace-data";

// Project
export const ADD_NEW_PROJECT = "/add/project";
export const UPDATE_PROJECT = "/update/project";
export const DELETE_PROJECT = "/delete/project";

// Pages > Team
export const GET_TEAMDATA = "/teamData";
export const DELETE_TEAMDATA = "/delete/teamData";
export const ADD_NEW_TEAMDATA = "/add/teamData";
export const UPDATE_TEAMDATA = "/update/teamData";

// File Manager
// Folder
export const GET_FOLDERS = "/folder";
export const DELETE_FOLDER = "/delete/folder";
export const ADD_NEW_FOLDER = "/add/folder";
export const UPDATE_FOLDER = "/update/folder";

// File
export const GET_FILES = "/file";
export const DELETE_FILE = "/delete/file";
export const ADD_NEW_FILE = "/add/file";
export const UPDATE_FILE = "/update/file";

// To do
export const GET_TODOS = "/todo";
export const DELETE_TODO = "/delete/todo";
export const ADD_NEW_TODO = "/add/todo";
export const UPDATE_TODO = "/update/todo";

// To do Project
export const GET_PROJECTS = "/projects";
export const ADD_NEW_TODO_PROJECT = "/add/project";

//JOB APPLICATION
export const GET_APPLICATION_LIST = "/application-list";
export const ADD_NEW_APPLICATION_LIST = "/add/application-list";
export const UPDATE_APPLICATION_LIST = "/update/application-list";
export const DELETE_APPLICATION_LIST = "/delete/application-list";

//JOB APPLICATION
export const GET_API_KEY = "/api-key";

// CANDIDATE LIST
export const GET_CANDIDATE = "/candidates";
export const ADD_NEW_CANDIDATE = "add/candidates";
export const UPDATE_CANDIDATE = "update/candidates";
export const DELETE_CANDIDATE = "delete/candidates"

export const GET_CANDIDATE_GRID = "/category-grid";
export const ADD_CANDIDATE_GRID = "/add/category-grid";

export const GET_CATEGORY_LIST = "/category-list";
export const ADD_CATEGORY_LIST = "/add/category-list";

---- File: src\slices\device\reducer.ts ----
import { createSlice } from "@reduxjs/toolkit";
import { getDevicesKpis, getDevicesList, getDevicesChartData } from "./thunk"; // Modificar import

export interface DevicesState {
  kpis: any[];
  devicesList: any[];
  chartData: any[]; // AÃ±adir propiedad para datos del grÃ¡fico
  loading: boolean;
  chartLoading: boolean; // AÃ±adir estado de carga especÃ­fico para el grÃ¡fico
  error: string | null;
}

const initialState: DevicesState = {
  kpis: [],
  devicesList: [],
  chartData: [], // Inicializar propiedad
  loading: false,
  chartLoading: false, // Inicializar
  error: null,
};

const devicesSlice = createSlice({
  name: "devices",
  initialState,
 reducers: {
    resetDevices(state) {
      state.kpis = [];
      state.devicesList = [];
      state.chartData = []; // AÃ±adir reset
      state.loading = false;
      state.chartLoading = false;
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Casos existentes para getDevicesKpis
      .addCase(getDevicesKpis.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getDevicesKpis.fulfilled, (state, action) => {
        state.loading = false;
        state.kpis = (action.payload as any) ?? [];
      })
      .addCase(getDevicesKpis.rejected, (state, action) => {
        state.loading = false;
        state.error = (action.payload as any) || action.error.message || "Failed to fetch device KPIs";
      })
      // Casos nuevos para getDevicesList
      .addCase(getDevicesList.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getDevicesList.fulfilled, (state, action) => {
        state.loading = false;
        state.devicesList = (action.payload as any) ?? [];
      })
      .addCase(getDevicesList.rejected, (state, action) => {
        state.loading = false;
        state.error = (action.payload as any) || action.error.message || "Failed to fetch devices list";
      })
      // Casos nuevos para getDevicesChartData
      .addCase(getDevicesChartData.pending, (state) => {
        state.chartLoading = true;
        state.error = null;
      })
      .addCase(getDevicesChartData.fulfilled, (state, action) => {
        state.chartLoading = false;
        state.chartData = (action.payload as any) ?? [];
      })
      .addCase(getDevicesChartData.rejected, (state, action) => {
        state.chartLoading = false;
        state.error = (action.payload as any) || action.error.message || "Failed to fetch chart data";
      });
  },
});

export const { resetDevices } = devicesSlice.actions;
export default devicesSlice.reducer;

---- File: src\slices\device\thunk.ts ----
import { createAsyncThunk } from "@reduxjs/toolkit";
import {
  getDevicesKpis as getDevicesKpisApi,
  getDevicesList as getDevicesListApi,
  getDevicesChartData as getDevicesChartDataApi
} from "../../helpers/fakebackend_helper";

// Thunk existente para KPIs (sin cambios)
export const getDevicesKpis = createAsyncThunk("device/getDevicesKpis", async () => {
  try {
    const response = getDevicesKpisApi();
    return response;
  } catch (error) {
    return error;
  }
});

// Thunk para lista de dispositivos (sin cambios)
export const getDevicesList = createAsyncThunk("device/getDevicesList", async () => {
  try {
    const response = getDevicesListApi();
    return response;
  } catch (error) {
    return error;
  }
});

// --- CORRECCIÃ“N AQUÃ ---
// Se elimina el try/catch para que createAsyncThunk maneje los errores automÃ¡ticamente.
export const getDevicesChartData = createAsyncThunk(
  "device/getDevicesChartData",
  async (params: { year: number, month: number }) => {
    const response = await getDevicesChartDataApi(params);
    return response;
  }
);

---- File: src\slices\index.ts ----
import { combineReducers } from "redux";

// Front
import LayoutReducer from "./layouts/reducer";

// Authentication
import LoginReducer from "./auth/login/reducer";
import AccountReducer from "./auth/register/reducer";
import ForgetPasswordReducer from "./auth/forgetpwd/reducer";
import ProfileReducer from "./auth/profile/reducer";

//Calendar
import CalendarReducer from "./calendar/reducer";
//Chat
import chatReducer from "./chat/reducer";
//Ecommerce
import EcommerceReducer from "./ecommerce/reducer";

//Project
import ProjectsReducer from "./projects/reducer";

// Tasks
import TasksReducer from "./tasks/reducer";

//Crypto
import CryptoReducer from "./crypto/reducer";

//TicketsList
import TicketsReducer from "./tickets/reducer";
//Crm
import CrmReducer from "./crm/reducer";

//Invoice
import InvoiceReducer from "./invoice/reducer";

//Mailbox
import MailboxReducer from "./mailbox/reducer";

// Dashboard Analytics
import DashboardAnalyticsReducer from "./dashboardAnalytics/reducer";

// Dashboard CRM
import DashboardCRMReducer from "./dashboardCRM/reducer";

// Dashboard Ecommerce
import DashboardEcommerceReducer from "./dashboardEcommerce/reducer";

// Dashboard Cryto
import DashboardCryptoReducer from "./dashboardCrypto/reducer";

// Dashboard Cryto
import DashboardProjectReducer from "./dashboardProject/reducer";

// Dashboard NFT
import DashboardNFTReducer from "./dashboardNFT/reducer";

// Dashboard JOb
import DashboardJobReducer from "./dashboardJob/reducer";

// Pages > Team
import TeamDataReducer from "./team/reducer";

// File Manager
import FileManagerReducer from "./fileManager/reducer";

// To do
import TodosReducer from "./todos/reducer";

// Job
import JobReducer from "./jobs/reducer";

// API Key
import APIKeyReducer from "./apiKey/reducer";

// Device
import DevicesReducer from "./device/reducer";

const rootReducer = combineReducers({
    Layout: LayoutReducer,
    Login: LoginReducer,
    Account: AccountReducer,
    ForgetPassword: ForgetPasswordReducer,
    Profile: ProfileReducer,
    Calendar: CalendarReducer,
    Chat: chatReducer,
    Projects: ProjectsReducer,
    Ecommerce: EcommerceReducer,
    Tasks: TasksReducer,
    Crypto: CryptoReducer,
    Tickets: TicketsReducer,
    Crm: CrmReducer,
    Invoice: InvoiceReducer,
    Mailbox: MailboxReducer,
    DashboardAnalytics: DashboardAnalyticsReducer,
    DashboardCRM: DashboardCRMReducer,
    DashboardEcommerce: DashboardEcommerceReducer,
    DashboardCrypto: DashboardCryptoReducer,
    DashboardProject: DashboardProjectReducer,
    DashboardNFT: DashboardNFTReducer,
    DashBoardJob: DashboardJobReducer,
    Team: TeamDataReducer,
    FileManager: FileManagerReducer,
    Todos: TodosReducer,
    Jobs: JobReducer,
    APIKey: APIKeyReducer,
    Devices: DevicesReducer,
});

export default rootReducer;

---- File: src\slices\thunks.ts ----
// Front
export * from "./layouts/thunk";

// Authentication
export * from "./auth/login/thunk";
export * from "./auth/register/thunk";
export * from "./auth/forgetpwd/thunk";
export * from "./auth/profile/thunk";

//Calendar
export * from "./calendar/thunk";
//Chat
export * from "./chat/thunk";
//Ecommerce
export * from "./ecommerce/thunk";

//Project
export * from "./projects/thunk";

// Tasks
export * from "./tasks/thunk";
//Crypto
export * from "./crypto/thunk";

//TicketsList
export * from "./tickets/thunk";
//Crm
export * from "./crm/thunk";

//Invoice
export * from "./invoice/thunk";

//Mailbox
export * from "./mailbox/thunk";

// Dashboard Analytics
export * from "./dashboardAnalytics/thunk";

// Dashboard CRM
export * from "./dashboardCRM/thunk";

// Dashboard Ecommerce
export * from "./dashboardEcommerce/thunk";

// Dashboard Cryto
export * from "./dashboardCrypto/thunk";

// Dashboard Cryto
export * from "./dashboardProject/thunk";

// Dashboard NFT
export * from "./dashboardNFT/thunk";

// Dashboard Job
export * from "./dashboardJob/thunk";

// Pages > Team
export * from "./team/thunk";

// File Manager
export * from "./fileManager/thunk";

// To do
export * from "./todos/thunk";

// Jobs
export * from "./jobs/thunk";

// API Key
export * from "./apiKey/thunk";

---- File: src\pages\Devices\components\DeviceWizard.tsx ----
import React, { useState } from "react";
import {
  Card,
  CardBody,
  Col,
  Row,
  Progress,
  Nav,
  NavItem,
  NavLink,
  TabContent,
  TabPane,
  Form,
  Input,
  Label,
  Button
} from "reactstrap";
import classnames from "classnames";

interface DeviceWizardProps {
  isOpen: boolean;
  toggle: () => void;
  onSave: (deviceData: any) => void;
}

const DeviceWizard: React.FC<DeviceWizardProps> = ({ isOpen, toggle, onSave }) => {
  const [activeTab, setActiveTab] = useState(1);
  const [progressValue, setProgressValue] = useState(25);
  const [passedSteps, setPassedSteps] = useState([1]);
  
  // Datos del formulario
  const [formData, setFormData] = useState({
    mssSerial: "",
    substation: "",
    supplyPoint: "",
    meterBrand: "",
    meterSerial: "",
    status: "online",
    firmware: "",
    installedAt: new Date().toISOString().split('T')[0]
  });

  const toggleTab = (tab: number, progress: number) => {
    if (activeTab !== tab) {
      const modifiedSteps = [...passedSteps, tab];
      
      if (tab >= 1 && tab <= 4) {
        setActiveTab(tab);
        setPassedSteps(modifiedSteps);
        setProgressValue(progress);
      }
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = () => {
    onSave(formData);
    toggle();
  };

  if (!isOpen) return null;

  return (
    <div className="modal fade show d-block" tabIndex={-1} role="dialog">
      <div className="modal-dialog modal-lg" role="document">
        <div className="modal-content">
          <div className="modal-header">
            <h5 className="modal-title">Asistente de Nuevo Dispositivo</h5>
            <button type="button" className="btn-close" onClick={toggle}></button>
          </div>
          <div className="modal-body">
            <Card>
              <CardBody>
                <div className="text-center pt-3 pb-4 mb-1">
                  <h5>Registrar Nuevo Dispositivo</h5>
                </div>

                {/* Barra de progreso */}
                <div className="progress-nav mb-4">
                  <Progress
                    value={progressValue}
                    style={{ height: "1px" }}
                  />
                  <Nav
                    className="nav-pills progress-bar-tab custom-nav"
                    role="tablist"
                  >
                    <NavItem>
                      <NavLink
                        className={classnames({
                          active: activeTab === 1,
                          done: activeTab <= 4 && activeTab >= 0,
                        }, "rounded-pill")}
                        onClick={() => toggleTab(1, 25)}
                      >
                        1
                      </NavLink>
                      <p className="text-center mt-1 fs-12">InformaciÃ³n BÃ¡sica</p>
                    </NavItem>
                    <NavItem>
                      <NavLink
                        className={classnames({
                          active: activeTab === 2,
                          done: activeTab <= 4 && activeTab > 1,
                        }, "rounded-pill")}
                        onClick={() => toggleTab(2, 50)}
                      >
                        2
                      </NavLink>
                      <p className="text-center mt-1 fs-12">UbicaciÃ³n</p>
                    </NavItem>
                    <NavItem>
                      <NavLink
                        className={classnames({
                          active: activeTab === 3,
                          done: activeTab <= 4 && activeTab > 2,
                        }, "rounded-pill")}
                        onClick={() => toggleTab(3, 75)}
                      >
                        3
                      </NavLink>
                      <p className="text-center mt-1 fs-12">ConfiguraciÃ³n</p>
                    </NavItem>
                    <NavItem>
                      <NavLink
                        className={classnames({
                          active: activeTab === 4,
                          done: activeTab <= 4 && activeTab > 3,
                        }, "rounded-pill")}
                        onClick={() => toggleTab(4, 100)}
                      >
                        4
                      </NavLink>
                      <p className="text-center mt-1 fs-12">ConfirmaciÃ³n</p>
                    </NavItem>
                  </Nav>
                </div>

                <TabContent activeTab={activeTab}>
                  {/* Paso 1: InformaciÃ³n BÃ¡sica */}
                  <TabPane tabId={1}>
                    <div>
                      <div className="mb-4">
                        <h5 className="mb-1">InformaciÃ³n BÃ¡sica del Dispositivo</h5>
                        <p className="text-muted">
                          Complete la informaciÃ³n bÃ¡sica del dispositivo
                        </p>
                      </div>
                      <Row>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Serial MSS</Label>
                            <Input
                              type="text"
                              name="mssSerial"
                              value={formData.mssSerial}
                              onChange={handleInputChange}
                              placeholder="Ej: MSS-001"
                            />
                          </div>
                        </Col>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">VersiÃ³n de Firmware</Label>
                            <Input
                              type="text"
                              name="firmware"
                              value={formData.firmware}
                              onChange={handleInputChange}
                              placeholder="Ej: 1.0.0"
                            />
                          </div>
                        </Col>
                      </Row>
                    </div>
                    <div className="d-flex align-items-start gap-3 mt-4">
                      <button
                        type="button"
                        className="btn btn-success btn-label right ms-auto nexttab"
                        onClick={() => toggleTab(2, 50)}
                      >
                        <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
                        Siguiente
                      </button>
                    </div>
                  </TabPane>

                  {/* Paso 2: UbicaciÃ³n */}
                  <TabPane tabId={2}>
                    <div>
                      <div className="mb-4">
                        <h5 className="mb-1">UbicaciÃ³n del Dispositivo</h5>
                        <p className="text-muted">
                          Especifique la ubicaciÃ³n del dispositivo
                        </p>
                      </div>
                      <Row>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">SubestaciÃ³n</Label>
                            <Input
                              type="text"
                              name="substation"
                              value={formData.substation}
                              onChange={handleInputChange}
                              placeholder="Nombre de subestaciÃ³n"
                            />
                          </div>
                        </Col>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Punto de Suministro</Label>
                            <Input
                              type="text"
                              name="supplyPoint"
                              value={formData.supplyPoint}
                              onChange={handleInputChange}
                              placeholder="Punto de suministro"
                            />
                          </div>
                        </Col>
                      </Row>
                    </div>
                    <div className="d-flex align-items-start gap-3 mt-4">
                      <button
                        type="button"
                        className="btn btn-light btn-label previestab"
                        onClick={() => toggleTab(1, 25)}
                      >
                        <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i>
                        Anterior
                      </button>
                      <button
                        type="button"
                        className="btn btn-success btn-label right ms-auto nexttab"
                        onClick={() => toggleTab(3, 75)}
                      >
                        <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
                        Siguiente
                      </button>
                    </div>
                  </TabPane>

                  {/* Paso 3: ConfiguraciÃ³n */}
                  <TabPane tabId={3}>
                    <div>
                      <div className="mb-4">
                        <h5 className="mb-1">ConfiguraciÃ³n del Medidor</h5>
                        <p className="text-muted">
                          Complete la informaciÃ³n del medidor asociado
                        </p>
                      </div>
                      <Row>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Marca del Medidor</Label>
                            <Input
                              type="text"
                              name="meterBrand"
                              value={formData.meterBrand}
                              onChange={handleInputChange}
                              placeholder="Ej: Brand A"
                            />
                          </div>
                        </Col>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Serial del Medidor</Label>
                            <Input
                              type="text"
                              name="meterSerial"
                              value={formData.meterSerial}
                              onChange={handleInputChange}
                              placeholder="Ej: MET-001"
                            />
                          </div>
                        </Col>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Estado</Label>
                            <Input
                              type="select"
                              name="status"
                              value={formData.status}
                              onChange={handleInputChange}
                            >
                              <option value="online">Online</option>
                              <option value="offline">Offline</option>
                              <option value="maintenance">Mantenimiento</option>
                            </Input>
                          </div>
                        </Col>
                        <Col lg={6}>
                          <div className="mb-3">
                            <Label className="form-label">Fecha de InstalaciÃ³n</Label>
                            <Input
                              type="date"
                              name="installedAt"
                              value={formData.installedAt}
                              onChange={handleInputChange}
                            />
                          </div>
                        </Col>
                      </Row>
                    </div>
                    <div className="d-flex align-items-start gap-3 mt-4">
                      <button
                        type="button"
                        className="btn btn-light btn-label previestab"
                        onClick={() => toggleTab(2, 50)}
                      >
                        <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i>
                        Anterior
                      </button>
                      <button
                        type="button"
                        className="btn btn-success btn-label right ms-auto nexttab"
                        onClick={() => toggleTab(4, 100)}
                      >
                        <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
                        Siguiente
                      </button>
                    </div>
                  </TabPane>

                  {/* Paso 4: ConfirmaciÃ³n */}
                  <TabPane tabId={4}>
                    <div>
                      <div className="text-center">
                        <div className="mb-4">
                          <i className="bx bx-party display-4 text-success"></i>
                        </div>
                        <h5>Â¡ConfirmaciÃ³n de Datos!</h5>
                        <p className="text-muted">
                          Revise la informaciÃ³n antes de guardar
                        </p>
                        
                        <div className="mt-4 text-start">
                          <h6>Resumen del Dispositivo:</h6>
                          <p><strong>Serial MSS:</strong> {formData.mssSerial}</p>
                          <p><strong>Firmware:</strong> {formData.firmware}</p>
                          <p><strong>SubestaciÃ³n:</strong> {formData.substation}</p>
                          <p><strong>Punto de Suministro:</strong> {formData.supplyPoint}</p>
                          <p><strong>Marca del Medidor:</strong> {formData.meterBrand}</p>
                          <p><strong>Serial del Medidor:</strong> {formData.meterSerial}</p>
                          <p><strong>Estado:</strong> {formData.status}</p>
                          <p><strong>Fecha de InstalaciÃ³n:</strong> {formData.installedAt}</p>
                        </div>
                      </div>
                    </div>
                    <div className="d-flex align-items-start gap-3 mt-4">
                      <button
                        type="button"
                        className="btn btn-light btn-label previestab"
                        onClick={() => toggleTab(3, 75)}
                      >
                        <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i>
                        Anterior
                      </button>
                      <button
                        type="button"
                        className="btn btn-success btn-label right ms-auto"
                        onClick={handleSubmit}
                      >
                        <i className="ri-check-double-line label-icon align-middle fs-16 ms-2"></i>
                        Confirmar y Guardar
                      </button>
                    </div>
                  </TabPane>
                </TabContent>
              </CardBody>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DeviceWizard;

---- File: src\pages\Devices\sections\DevicesChart.tsx ----
// src/pages/Devices/sections/DevicesChart.tsx

import React from "react";
import { Card, CardBody, CardHeader, Col, Input, Label, Row, Spinner } from "reactstrap";
import ReactApexChart from "react-apexcharts";
import { format } from "date-fns";
import { es } from "date-fns/locale";

interface DevicesChartProps {
  title?: string;
  data: any[];
  loading: boolean;
  availableYears: number[];
  yearFilter: string;
  monthFilter: string;
  onFilterChange: (filterType: 'year' | 'month', value: string) => void;
}

const DevicesChart: React.FC<DevicesChartProps> = ({
  title = "Dispositivos Online por DÃ­a",
  data,
  loading,
  availableYears,
  yearFilter,
  monthFilter,
  onFilterChange
}) => {
  const months = Array.from({ length: 12 }, (_, i) => ({
    value: String(i + 1),
    label: format(new Date(2000, i, 1), "MMMM", { locale: es }),
  }));

  const series = [
    {
      name: "Online",
      data: data.map(item => item.online),
    },
  ];

  const options: ApexCharts.ApexOptions = {
    chart: {
      type: "line",
      height: 350,
      zoom: { enabled: false },
      toolbar: { show: false },
    },
    stroke: {
      curve: "smooth",
      width: 3,
    },
    colors: ["#405189"], // Color principal de Velzon
    xaxis: {
      categories: data.map(item => new Date(item.date).getDate()),
      title: {
        text: "DÃ­a del Mes",
      },
    },
    yaxis: {
      title: {
        text: "NÂº de Dispositivos",
      },
    },
    tooltip: {
      x: {
        formatter: (val: number) => `DÃ­a ${val}`,
      },
      y: {
        formatter: (val: number) => `${val} dispositivos`,
      },
    },
    grid: {
      borderColor: "#f1f1f1",
    },
  };

  return (
    <Card>
      <CardHeader className="d-flex justify-content-between align-items-center">
        <h4 className="card-title mb-0">{title}</h4>
        <div className="d-flex gap-3">
          <div className="d-flex align-items-center">
            <Label htmlFor="chartYearFilter" className="me-2 mb-0">AÃ±o</Label>
            <Input
              type="select"
              id="chartYearFilter"
              bsSize="sm"
              value={yearFilter}
              onChange={(e) => onFilterChange('year', e.target.value)}
              style={{ width: "100px" }}
            >
              {availableYears.map(year => (
                <option key={year} value={String(year)}>{year}</option>
              ))}
            </Input>
          </div>
          <div className="d-flex align-items-center">
            <Label htmlFor="chartMonthFilter" className="me-2 mb-0">Mes</Label>
            <Input
              type="select"
              id="chartMonthFilter"
              bsSize="sm"
              value={monthFilter}
              onChange={(e) => onFilterChange('month', e.target.value)}
              style={{ width: "120px" }}
            >
              {months.map(month => (
                <option key={month.value} value={month.value}>{month.label}</option>
              ))}
            </Input>
          </div>
        </div>
      </CardHeader>
      <CardBody>
        {loading ? (
          <div className="d-flex justify-content-center align-items-center" style={{ height: "350px" }}>
            <Spinner color="primary">Cargando...</Spinner>
          </div>
        ) : (
          <ReactApexChart
            options={options}
            series={series}
            type="line"
            height={350}
            className="apex-charts"
          />
        )}
      </CardBody>
    </Card>
  );
};

export default DevicesChart;

---- File: src\pages\Devices\sections\DevicesKpis.tsx ----
// src/pages/Devices/sections/DevicesKpis.tsx
import React from "react";
import { Row, Col, Card, CardBody } from "reactstrap";
import CountUp from "react-countup";
import FeatherIcon from "feather-icons-react";

interface DevicesKpisProps {
  items: any[]; // siguiendo el estilo del template (sin tipos estrictos)
}

const DevicesKpis: React.FC<DevicesKpisProps> = ({ items }) => {
  return (
    <Row>
      {(items || []).map((item: any, idx: number) => (
        <Col xl={3} md={6} key={item.id ?? idx}>
          <Card className="card-animate">
            <CardBody>
              <div className="d-flex align-items-center">
                <div className="flex-grow-1">
                  <p className="text-uppercase fw-medium text-muted mb-0">
                    {item.label || item.title}
                  </p>
                </div>
                {(item.percentage || item.delta) && (
                  <div className="flex-shrink-0">
                    <h5
                      className={
                        "fs-14 mb-0 text-" +
                        (item.percentageClass ||
                          (Number(item.delta) >= 0 ? "success" : "danger"))
                      }
                    >
                      <i className="ri-arrow-right-up-line fs-13 align-middle"></i>{" "}
                      {item.percentage ??
                        (Number(item.delta) >= 0
                          ? `+${item.delta}%`
                          : `${item.delta}%`)}
                    </h5>
                  </div>
                )}
              </div>

              <div className="d-flex align-items-end justify-content-between mt-4">
                <div>
                  <h4 className="fs-22 fw-semibold ff-secondary mb-4">
                    <CountUp
                      start={0}
                      end={Number(item.counter ?? item.value ?? 0)}
                      duration={4}
                      className="counter-value"
                      decimals={item.decimals ?? 0}
                      prefix={item.prefix || ""}
                      suffix={item.suffix || ""}
                    />
                  </h4>
                  {item.badge && (
                    <span className="badge bg-warning me-1">{item.badge}</span>
                  )}{" "}
                  {item.caption && (
                    <span className="text-muted">{item.caption}</span>
                  )}
                </div>

                <div className="avatar-sm flex-shrink-0">
                  <span className="avatar-title bg-light rounded fs-3">
                    <FeatherIcon
                      icon={item.feaIcon || item.icon || "cpu"}
                      className="text-success icon-dual-success"
                    />
                  </span>
                </div>
              </div>
            </CardBody>
          </Card>
        </Col>
      ))}
    </Row>
  );
};

export default DevicesKpis;

---- File: src\pages\Devices\sections\DevicesMap.tsx ----
// src/pages/Devices/sections/DevicesMap.tsx

import React, { useMemo, useState } from "react";
import { Card, CardBody, CardHeader, Input, Label, Button, Row, Col } from "reactstrap";
import { MapContainer, TileLayer, Marker, Popup, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

// Fix para los iconos
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),
  iconUrl: require('leaflet/dist/images/marker-icon.png'),
  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),
});

// Hacemos que las props sean flexibles, aceptando un array de cualquier objeto
interface DevicesMapProps {
  devices: any[];
  title?: string;
}

const MapUpdater: React.FC<{ devices: any[] }> = ({ devices }) => {
  const map = useMap();
  React.useEffect(() => {
    if (devices && devices.length > 0) {
      const validCoords = devices.filter(d => d.lat && d.lng);
      if (validCoords.length > 0) {
        const group = new L.FeatureGroup(validCoords.map(device => L.marker([device.lat, device.lng])));
        map.fitBounds(group.getBounds(), { padding: [50, 50] });
      }
    } else {
        map.setView([18.4861, -69.9312], 13);
    }
  }, [devices, map]);
  return null;
};

const DevicesMap: React.FC<DevicesMapProps> = ({ devices, title = "Mapa de Ubicaciones de Dispositivos" }) => {
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [searchFilter, setSearchFilter] = useState<string>("");

  const filteredDevicesForMap = useMemo(() => {
    return devices.filter(device => {
      if (!device.lat || !device.lng) return false;
      const statusMatch = statusFilter === "all" || device.status === statusFilter;
      const term = searchFilter.toLowerCase();
      const searchMatch = term === "" || 
        device.mssSerial.toLowerCase().includes(term) ||
        device.substation.toLowerCase().includes(term) ||
        device.supplyPoint.toLowerCase().includes(term);
      return statusMatch && searchMatch;
    });
  }, [devices, statusFilter, searchFilter]);

  const statusColors: { [key: string]: string } = {
    online: "#28a745",
    offline: "#dc3545",
    maintenance: "#0d6efd"
  };

  const createStatusIcon = (status: string) => {
    const color = statusColors[status] || "#6c757d";
    return new L.DivIcon({
      html: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
      className: "custom-leaflet-marker",
      iconSize: [20, 20],
      iconAnchor: [10, 10],
      popupAnchor: [0, -10]
    });
  };

  const clearFilters = () => {
    setStatusFilter("all");
    setSearchFilter("");
  };

  return (
    <Card>
      <CardHeader><h4 className="card-title mb-0">{title}</h4></CardHeader>
      <CardBody>
        <Row className="mb-3">
          <Col lg={4}>
            <Label htmlFor="mapStatusFilter">Filtrar por Estado</Label>
            <Input type="select" id="mapStatusFilter" value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)}>
              <option value="all">Todos los estados</option>
              <option value="online">Online</option>
              <option value="offline">Offline</option>
              <option value="maintenance">Mantenimiento</option>
            </Input>
          </Col>
          <Col lg={4}>
            <Label htmlFor="mapSearchFilter">Buscar en Mapa</Label>
            <Input type="text" id="mapSearchFilter" placeholder="Buscar por serial, subestaciÃ³n..." value={searchFilter} onChange={(e) => setSearchFilter(e.target.value)} />
          </Col>
          <Col lg={4} className="d-flex align-items-end">
            <Button color="light" onClick={clearFilters} className="w-100"><i className="ri-refresh-line me-1"></i> Limpiar Filtros</Button>
          </Col>
        </Row>
        <div style={{ height: "450px", width: "100%", borderRadius: "0.25rem", overflow: "hidden" }}>
          <MapContainer center={[18.4861, -69.9312]} zoom={13} style={{ height: "100%", width: "100%" }}>
            <TileLayer attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
            <MapUpdater devices={filteredDevicesForMap} />
            {filteredDevicesForMap.map((device) => (
              <Marker key={device.id} position={[device.lat, device.lng]} icon={createStatusIcon(device.status)}>
                <Popup>
                  <div>
                    <h6 className="fw-bold mb-2">{device.mssSerial}</h6>
                    <p className="mb-1"><strong>SubestaciÃ³n:</strong> {device.substation}</p>
                    <p className="mb-1"><strong>Punto:</strong> {device.supplyPoint}</p>
                    <p className="mb-1"><strong>Estado:</strong>{" "}
                      <span className={`badge text-uppercase ${device.status === "online" ? "bg-success-subtle text-success" : device.status === "offline" ? "bg-danger-subtle text-danger" : "bg-primary-subtle text-primary"}`}>
                        {device.status}
                      </span>
                    </p>
                  </div>
                </Popup>
              </Marker>
            ))}
          </MapContainer>
        </div>
        <div className="mt-3">
          <div className="d-flex justify-content-center flex-wrap gap-4">
            {Object.entries(statusColors).map(([status, color]) => (
              <div key={status} className="d-flex align-items-center">
                <div style={{ width: "16px", height: "16px", backgroundColor: color, borderRadius: "50%", marginRight: "8px" }}></div>
                <span className="text-capitalize">{status}</span>
              </div>
            ))}
          </div>
        </div>
      </CardBody>
    </Card>
  );
};

export default DevicesMap;

---- File: src\pages\Devices\sections\DevicesTable.tsx ----
import React, { useMemo } from "react";
import {
  Card,
  CardHeader,
  CardBody,
  Col,
  UncontrolledDropdown,
  DropdownToggle,
  DropdownMenu,
  DropdownItem,
  Button,
  Input,
  Label,
} from "reactstrap";
import TableContainer from "../../../Components/Common/TableContainer";
import FeatherIcon from "feather-icons-react";

type Props = {
  title?: string;
  rows: any[];
  onAddDevice: () => void;
  onEditDevice: (device: any) => void;
  onDeleteDevice: (device: any) => void;
  onMaintenanceDevice: (device: any) => void;
  onViewAlarms: (device: any) => void;
  onTestDevice: (device: any) => void;
  onConfigureDevice: (device: any) => void;
  availableYears: number[];
  yearFilter: string;
  monthFilter: string;
  onFilterChange: (filterType: 'year' | 'month', value: string) => void;
  onClearFilters: () => void;
};

const DevicesTable: React.FC<Props> = ({
  title = "Listado de Dispositivos",
  rows,
  onAddDevice,
  onEditDevice,
  onDeleteDevice,
  onMaintenanceDevice,
  onViewAlarms,
  onTestDevice,
  onConfigureDevice,
  availableYears,
  yearFilter,
  monthFilter,
  onFilterChange,
  onClearFilters
}) => {
  const columns = useMemo(
    () => [
      {
        header: "MSS SERIAL",
        accessorKey: "mssSerial",
        enableColumnFilter: false, // <-- Esto es lo que deshabilita el filtro para la columna
        cell: (cell: any) => <span className="fw-semibold">{cell.getValue()}</span>,
      },
      {
        header: "SUBESTACIÃ“N",
        accessorKey: "substation",
        enableColumnFilter: false,
      },
      {
        header: "PUNTO",
        accessorKey: "supplyPoint",
        enableColumnFilter: false,
      },
      {
        header: "MARCA",
        accessorKey: "meterBrand",
        enableColumnFilter: false,
      },
      {
        header: "MEDIDOR",
        accessorKey: "meterSerial",
        enableColumnFilter: false,
      },
      {
        header: "ESTADO",
        accessorKey: "status",
        enableColumnFilter: false,
        cell: (cell: any) => {
          const status = String(cell.getValue() || "").toLowerCase();
          switch (status) {
            case "online": return <span className="badge text-uppercase bg-success-subtle text-success">Online</span>;
            case "maintenance": return <span className="badge text-uppercase bg-primary-subtle text-primary">Mantenimiento</span>;
            case "offline": return <span className="badge text-uppercase bg-danger-subtle text-danger">Offline</span>;
            default: return <span className="badge text-uppercase bg-secondary-subtle text-secondary">{status}</span>;
          }
        },
      },
      {
        header: "ACCIÃ“N",
        enableColumnFilter: false,
        cell: (cell: any) => {
          const device = cell.row.original;
          return (
            <UncontrolledDropdown>
              <DropdownToggle href="#" className="btn btn-soft-secondary btn-sm dropdown" tag="button">
                <i className="ri-more-fill align-middle"></i>
              </DropdownToggle>
              <DropdownMenu className="dropdown-menu-end">
                <DropdownItem onClick={() => onEditDevice(device)}><i className="ri-pencil-fill align-bottom me-2 text-muted"></i> Editar</DropdownItem>
                <DropdownItem onClick={() => onConfigureDevice(device)}><i className="ri-settings-3-line align-bottom me-2 text-muted"></i> Configurar</DropdownItem>
                <DropdownItem onClick={() => onMaintenanceDevice(device)}><i className="ri-tools-line align-bottom me-2 text-muted"></i> Mantenimiento</DropdownItem>
                <DropdownItem onClick={() => onTestDevice(device)}><i className="ri-flask-line align-bottom me-2 text-muted"></i> Pruebas</DropdownItem>
                <DropdownItem onClick={() => onViewAlarms(device)}><i className="ri-flashlight-line align-bottom me-2 text-muted"></i> Alarmas</DropdownItem>
                <DropdownItem divider />
                <DropdownItem onClick={() => onDeleteDevice(device)} className="text-danger"><i className="ri-delete-bin-fill align-bottom me-2 text-muted"></i> Eliminar</DropdownItem>
              </DropdownMenu>
            </UncontrolledDropdown>
          );
        },
      },
  ], [onEditDevice, onDeleteDevice, onMaintenanceDevice, onViewAlarms, onTestDevice, onConfigureDevice]);

  const months = [
    { label: 'Enero', value: 1 }, { label: 'Febrero', value: 2 }, { label: 'Marzo', value: 3 },
    { label: 'Abril', value: 4 }, { label: 'Mayo', value: 5 }, { label: 'Junio', value: 6 },
    { label: 'Julio', value: 7 }, { label: 'Agosto', value: 8 }, { label: 'Septiembre', value: 9 },
    { label: 'Octubre', value: 10 }, { label: 'Noviembre', value: 11 }, { label: 'Diciembre', value: 12 },
  ];

  return (
    <Col lg={12}>
      <Card id="devicesList">
        <CardHeader className="border-0">
          <div className="d-flex align-items-center">
            <h5 className="card-title mb-0 flex-grow-1">{title}</h5>
            <div className="flex-shrink-0">
              <Button color="danger" onClick={onAddDevice}>
                <i className="ri-add-line align-bottom me-1"></i> Nuevo Dispositivo
              </Button>
            </div>
          </div>
        </CardHeader>

        <CardBody className="border border-dashed border-end-0 border-start-0">
          <div className="d-flex flex-wrap align-items-center gap-3">
            <div className="flex-shrink-0">
                <Label className="mb-0">Filtrar por fecha:</Label>
            </div>
            <div style={{minWidth: "150px"}}>
                <Input type="select" value={yearFilter} onChange={(e) => onFilterChange('year', e.target.value)}>
                    <option value="all">Todos los AÃ±os</option>
                    {availableYears.map(year => <option key={year} value={year}>{year}</option>)}
                </Input>
            </div>
             <div style={{minWidth: "150px"}}>
                <Input type="select" value={monthFilter} onChange={(e) => onFilterChange('month', e.target.value)}>
                    <option value="all">Todos los Meses</option>
                    {months.map(month => <option key={month.value} value={month.value}>{month.label}</option>)}
                </Input>
            </div>
            <div className="flex-shrink-0">
                <Button color="primary" onClick={onClearFilters}>
                    <i className="ri-refresh-line align-bottom me-1"></i> Limpiar Filtros
                </Button>
            </div>
          </div>
        </CardBody>

        <CardBody className="pt-0">
          {rows && rows.length > 0 ? (
            <TableContainer
              columns={columns}
              data={rows}
              isGlobalFilter={true}
              customPageSize={10}
              theadClass="text-muted text-uppercase"
              SearchPlaceholder="Buscar en la tabla..."
            />
          ) : (
            <div className="text-center py-5">
              <div className="avatar-md mx-auto mb-4">
                <div className="avatar-title bg-primary-subtle text-primary rounded-circle fs-24">
                  <FeatherIcon icon="cpu" />
                </div>
              </div>
              <h5 className="mt-2">No se encontraron dispositivos</h5>
              <p className="text-muted">
                Intenta ajustar tus filtros o aÃ±ade un nuevo dispositivo.
              </p>
            </div>
          )}
        </CardBody>
      </Card>
    </Col>
  );
};

export default DevicesTable;

---- File: src\pages\Devices\sections\DeviceTestWizardModal.tsx ----
import React, { useState, useEffect } from "react";
import {
  Modal,
  ModalHeader,
  ModalBody,
  Nav,
  NavItem,
  NavLink,
  TabContent,
  TabPane,
  Row,
  Col,
  Button,
} from "reactstrap";
import classnames from "classnames";

// --- Datos de ConfiguraciÃ³n de Pruebas ---
const testGroups = [
  {
    title: "Corrientes",
    points: [
      { id: 'current_l1', label: 'Corriente L1' },
      { id: 'current_l2', label: 'Corriente L2' },
      { id: 'current_l3', label: 'Corriente L3' },
    ]
  },
  {
    title: "Voltajes",
    points: [
      { id: 'voltage_vl1', label: 'Voltaje VL1' },
      { id: 'voltage_vl2', label: 'Voltaje VL2' },
      { id: 'voltage_vl3', label: 'Voltaje VL3' },
    ]
  },
  {
    title: "Relays",
    points: [
      { id: 'relay_1', label: 'Relay 1' },
      { id: 'relay_2', label: 'Relay 2' },
    ]
  },
  {
    title: "Entradas Digitales",
    points: [
      { id: 'input_d1', label: 'Entrada D1' },
      { id: 'input_d2', label: 'Entrada D2' },
      { id: 'input_d3', label: 'Entrada D3' },
      { id: 'input_d4', label: 'Entrada D4' },
    ]
  },
];

// --- Componente para mostrar el resultado de la prueba ---
const TestResultDisplay = ({ result }: { result?: { status: string } }) => {
  if (!result) return <div style={{ width: "24px", height: "24px" }} />;

  switch(result.status) {
    case 'testing':
      return <i className="ri-loader-4-line fs-20 text-primary animation-spin"></i>;
    case 'fail':
      return <i className="ri-close-circle-line fs-20 text-danger"></i>;
    case 'ok':
      return <i className="ri-checkbox-circle-line fs-20 text-success"></i>;
    default:
      return <div style={{ width: "24px", height: "24px" }} />;
  }
};

// --- Componente Principal del Wizard ---
interface DeviceTestWizardModalProps {
  isOpen: boolean;
  toggle: () => void;
  device: any | null;
}

const DeviceTestWizardModal: React.FC<DeviceTestWizardModalProps> = ({ isOpen, toggle, device }) => {
  const [activeTab, setActiveTab] = useState(1);
  const [testResults, setTestResults] = useState<Record<string, { status: string }>>({});

  useEffect(() => {
    // Reiniciar estado cuando se abre el modal
    if (isOpen) {
      setActiveTab(1);
      setTestResults({});
    }
  }, [isOpen]);

  const toggleTab = (tab: number) => {
    if (activeTab !== tab) {
      setActiveTab(tab);
    }
  };

  const handleTest = (pointId: string) => {
    // 1. Marcar como "probando"
    setTestResults(prev => ({ ...prev, [pointId]: { status: 'testing' } }));

    // 2. Simular llamada a la API con un timeout
    setTimeout(() => {
      const didFail = Math.random() < 0.15; // 15% de probabilidad de fallo
      setTestResults(prev => ({
        ...prev,
        [pointId]: { status: didFail ? 'fail' : 'ok' }
      }));
    }, 1500 + Math.random() * 1000); // DuraciÃ³n variable
  };

  return (
    <Modal isOpen={isOpen} toggle={toggle} centered size="lg">
      <ModalHeader toggle={toggle}>
        Asistente de Pruebas: {device?.mssSerial}
      </ModalHeader>
      <ModalBody className="p-4">
        <Nav className="nav-pills nav-justified" role="tablist">
          {testGroups.map((group, index) => (
            <NavItem key={group.title}>
              <NavLink
                className={classnames({ active: activeTab === index + 1 })}
                onClick={() => toggleTab(index + 1)}
              >
                {group.title}
              </NavLink>
            </NavItem>
          ))}
        </Nav>

        <TabContent activeTab={activeTab} className="mt-4">
          {testGroups.map((group, index) => (
            <TabPane tabId={index + 1} key={group.title}>
              <h5 className="mb-3">{group.title}</h5>
              {group.points.map(point => (
                <Row key={point.id} className="align-items-center border-bottom py-2">
                  <Col>
                    <span className="fw-medium">{point.label}</span>
                  </Col>
                  <Col xs="auto" className="d-flex align-items-center gap-4">
                    <Button
                      size="sm"
                      color="primary"
                      outline
                      style={{ width: "100px" }}
                      onClick={() => handleTest(point.id)}
                      disabled={testResults[point.id]?.status === 'testing'}
                    >
                      {testResults[point.id]?.status === 'testing' ? "Probando..." : "Probar"}
                    </Button>
                    <div className="text-center" style={{ width: "50px" }}>
                      <TestResultDisplay result={testResults[point.id]} />
                    </div>
                  </Col>
                </Row>
              ))}
            </TabPane>
          ))}
        </TabContent>

        <div className="d-flex justify-content-between mt-4">
            <Button color="light" onClick={() => toggleTab(activeTab - 1)} disabled={activeTab === 1}>
                Anterior
            </Button>
            {activeTab === testGroups.length ? (
                 <Button color="success" onClick={toggle}>Finalizar</Button>
            ) : (
                <Button color="primary" onClick={() => toggleTab(activeTab + 1)}>
                    Siguiente
                </Button>
            )}
        </div>
      </ModalBody>
    </Modal>
  );
};

export default DeviceTestWizardModal;

---- File: src\pages\Devices\sections\DeviceWizardModal.tsx ----
import React, { useState, useEffect } from "react";
import {
  Modal,
  ModalHeader,
  ModalBody,
  Progress,
  Nav,
  NavItem,
  NavLink,
  TabContent,
  TabPane,
  Row,
  Col,
  Label,
  Input,
  Button,
  FormFeedback, // Para validaciÃ³n
} from "reactstrap";
import classnames from "classnames";

// Define la estructura de datos que manejarÃ¡ el formulario
const initialFormData = {
  // Paso 1: SubestaciÃ³n
  subName: "",
  subLat: "",
  subLng: "",
  // Paso 2: Punto de MediciÃ³n
  spKind: "Compra",
  spCode: "",
  spName: "",
  spLat: "",
  spLng: "",
  spStatus: "Active",
  spUnr: "",
  // Paso 3: Medidor
  meterBrand: "",
  meterSerial: "",
  meterDate: "",
  meterBrandBackup: "",
  meterSerialBackup: "",
  meterDateBackup: "",
  // Paso 4: Dispositivo
  mssSerial: "",
  firmware: "",
  devDate: new Date().toISOString().split("T")[0],
  devStatus: "online",
};


interface DeviceWizardModalProps {
  isOpen: boolean;
  toggle: () => void;
  onSave: (deviceData: any) => void;
  deviceToEdit?: any | null; // El objeto debe contener todos los campos del formulario
}

const DeviceWizardModal: React.FC<DeviceWizardModalProps> = ({ isOpen, toggle, onSave, deviceToEdit }) => {
  const [activeTab, setActiveTab] = useState(1);
  const [passedSteps, setPassedSteps] = useState([1]);
  const [progressValue, setProgressValue] = useState(0);
  const [formData, setFormData] = useState(initialFormData);

  const isEditMode = !!deviceToEdit;

  useEffect(() => {
    if (isOpen) {
      if (isEditMode && deviceToEdit) {
        // En modo ediciÃ³n, se asume que 'deviceToEdit' tiene una estructura aplanada
        // que coincide con 'initialFormData'. La pÃ¡gina principal es responsable de prepararlo.
        setFormData(deviceToEdit);
        setPassedSteps([1, 2, 3, 4]);
      } else {
        setFormData(initialFormData);
        setPassedSteps([1]);
      }
      setActiveTab(1);
      setProgressValue(0);
    }
  }, [isOpen, deviceToEdit, isEditMode]);

  const toggleTab = (tab: number) => {
    if (activeTab !== tab) {
      if (passedSteps.includes(tab) || tab === activeTab + 1) {
        const newPassedSteps = [...passedSteps];
        if (!newPassedSteps.includes(tab)) {
          newPassedSteps.push(tab);
        }
        setPassedSteps(newPassedSteps);
        setActiveTab(tab);
        setProgressValue((tab - 1) * (100 / 3));
      }
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = () => {
    // AquÃ­ puedes aÃ±adir validaciones antes de guardar
    onSave(formData);
    toggle();
  };

  const steps = ["SubestaciÃ³n", "Punto", "Medidor", "Dispositivo"];

  return (
    <Modal isOpen={isOpen} toggle={toggle} centered size="lg" scrollable>
      <ModalHeader toggle={toggle} className="pb-0 border-0">
        <h5 className="modal-title">
          {isEditMode ? `Editando Dispositivo: ${deviceToEdit?.mssSerial || ''}` : "Asistente para Nuevo Dispositivo"}
        </h5>
      </ModalHeader>
      <ModalBody className="p-4 pt-2">
        <div className="progress-nav mb-4">
          <Progress value={progressValue} style={{ height: "1px" }} />
          <Nav className="nav-pills progress-bar-tab custom-nav" role="tablist">
            {steps.map((step, index) => {
              const tabIndex = index + 1;
              return (
                <NavItem key={tabIndex}>
                  <NavLink
                    tag="button"
                    className={classnames({ active: activeTab === tabIndex, done: activeTab > tabIndex }, "rounded-pill")}
                    onClick={() => toggleTab(tabIndex)}
                    disabled={!passedSteps.includes(tabIndex)}
                  >
                    {tabIndex}
                  </NavLink>
                </NavItem>
              );
            })}
          </Nav>
        </div>

        <TabContent activeTab={activeTab}>
          {/* PASO 1: SubestaciÃ³n */}
          <TabPane tabId={1}>
            <div className="mb-4">
              <h5 className="mb-1">Paso 1: Datos de la SubestaciÃ³n</h5>
              <p className="text-muted">InformaciÃ³n de la ubicaciÃ³n principal.</p>
            </div>
            <Row>
              <Col lg={12}><Label htmlFor="subName">Nombre</Label><Input id="subName" name="subName" value={formData.subName} onChange={handleInputChange} placeholder="SubestaciÃ³n Principal" /></Col>
            </Row>
            <Row className="mt-3">
              <Col lg={6}><Label htmlFor="subLat">Latitud</Label><Input id="subLat" name="subLat" value={formData.subLat} onChange={handleInputChange} placeholder="18.4861" /></Col>
              <Col lg={6}><Label htmlFor="subLng">Longitud</Label><Input id="subLng" name="subLng" value={formData.subLng} onChange={handleInputChange} placeholder="-69.9312" /></Col>
            </Row>
            <div className="d-flex align-items-start gap-3 mt-4">
              <Button color="success" className="btn-label right ms-auto" onClick={() => toggleTab(2)}>
                Siguiente <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
              </Button>
            </div>
          </TabPane>

          {/* PASO 2: Punto de MediciÃ³n */}
          <TabPane tabId={2}>
            <div className="mb-4">
                <h5 className="mb-1">Paso 2: Datos del Punto de MediciÃ³n</h5>
                <p className="text-muted">Detalles especÃ­ficos del punto de suministro.</p>
            </div>
            <Row>
              <Col md={6}><Label htmlFor="spKind">Tipo</Label><Input type="select" id="spKind" name="spKind" value={formData.spKind} onChange={handleInputChange}><option>Compra</option><option>Circuito</option><option>UNR</option><option>Frontera</option></Input></Col>
              <Col md={6}><Label htmlFor="spCode">CÃ³digo</Label><Input id="spCode" name="spCode" value={formData.spCode} onChange={handleInputChange} placeholder="INLET-1" /></Col>
            </Row>
            <Row className="mt-3">
              <Col md={6}><Label htmlFor="spName">Nombre</Label><Input id="spName" name="spName" value={formData.spName} onChange={handleInputChange} placeholder="Punto de Compra S1" /></Col>
              <Col md={6}><Label htmlFor="spStatus">Estado</Label><Input type="select" id="spStatus" name="spStatus" value={formData.spStatus} onChange={handleInputChange}><option value="Active">Activo</option><option value="Inactive">Inactivo</option></Input></Col>
            </Row>
             {/* Campo condicional para UNR */}
            {formData.spKind === 'UNR' && (
              <Row className="mt-3">
                <Col><Label htmlFor="spUnr">UNR ID</Label><Input id="spUnr" name="spUnr" value={formData.spUnr} onChange={handleInputChange} placeholder="5001" /></Col>
              </Row>
            )}
            <div className="d-flex align-items-start gap-3 mt-4">
              <Button color="link" className="text-decoration-none btn-label" onClick={() => toggleTab(1)}>
                 <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i> Anterior
              </Button>
              <Button color="success" className="btn-label right ms-auto" onClick={() => toggleTab(3)}>
                Siguiente <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
              </Button>
            </div>
          </TabPane>
          
          {/* PASO 3: Medidor */}
          <TabPane tabId={3}>
            <div className="mb-4">
                <h5 className="mb-1">Paso 3: Datos del Medidor</h5>
                <p className="text-muted">InformaciÃ³n del equipo de mediciÃ³n fÃ­sico.</p>
            </div>
            
            {/* LÃ³gica condicional para medidores */}
            <h6 className="fw-semibold">Medidor Principal</h6>
            <Row>
                <Col md={6}><Label>Marca</Label><Input name="meterBrand" value={formData.meterBrand} onChange={handleInputChange} placeholder="Marca del medidor" /></Col>
                <Col md={6}><Label>Serial</Label><Input name="meterSerial" value={formData.meterSerial} onChange={handleInputChange} placeholder="Serial del medidor" /></Col>
            </Row>
            <Row className="mt-3">
                 <Col><Label>Fecha de InstalaciÃ³n</Label><Input type="date" name="meterDate" value={formData.meterDate} onChange={handleInputChange} /></Col>
            </Row>

            {formData.spKind === 'Compra' && (
                <>
                    <hr className="my-4" />
                    <h6 className="fw-semibold">Medidor de Respaldo (Backup)</h6>
                    <Row>
                        <Col md={6}><Label>Marca</Label><Input name="meterBrandBackup" value={formData.meterBrandBackup} onChange={handleInputChange} placeholder="Marca medidor backup" /></Col>
                        <Col md={6}><Label>Serial</Label><Input name="meterSerialBackup" value={formData.meterSerialBackup} onChange={handleInputChange} placeholder="Serial medidor backup" /></Col>
                    </Row>
                     <Row className="mt-3">
                        <Col><Label>Fecha de InstalaciÃ³n</Label><Input type="date" name="meterDateBackup" value={formData.meterDateBackup} onChange={handleInputChange} /></Col>
                    </Row>
                </>
            )}

            <div className="d-flex align-items-start gap-3 mt-4">
              <Button color="link" className="text-decoration-none btn-label" onClick={() => toggleTab(2)}>
                 <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i> Anterior
              </Button>
              <Button color="success" className="btn-label right ms-auto" onClick={() => toggleTab(4)}>
                Siguiente <i className="ri-arrow-right-line label-icon align-middle fs-16 ms-2"></i>
              </Button>
            </div>
          </TabPane>
          
          {/* PASO 4: Dispositivo MSS y Guardar */}
          <TabPane tabId={4}>
             <div className="mb-4">
                <h5 className="mb-1">Paso 4: Datos del Dispositivo MSS</h5>
                <p className="text-muted">InformaciÃ³n final del hardware de comunicaciÃ³n.</p>
            </div>
            <Row>
                <Col md={6}><Label>Serial MSS</Label><Input name="mssSerial" value={formData.mssSerial} onChange={handleInputChange} placeholder="MSS-1025" /></Col>
                <Col md={6}><Label>Firmware</Label><Input name="firmware" value={formData.firmware} onChange={handleInputChange} placeholder="1.2.7" /></Col>
            </Row>
            <Row className="mt-3">
                <Col><Label>Fecha de InstalaciÃ³n</Label><Input type="date" name="devDate" value={formData.devDate} onChange={handleInputChange} /></Col>
            </Row>
            <div className="d-flex align-items-start gap-3 mt-4">
              <Button color="link" className="text-decoration-none btn-label" onClick={() => toggleTab(3)}>
                 <i className="ri-arrow-left-line label-icon align-middle fs-16 me-2"></i> Anterior
              </Button>
              <Button color="primary" className="btn-label right ms-auto" onClick={handleSubmit}>
                <i className="ri-save-3-line label-icon align-middle fs-16 ms-2"></i> Guardar Dispositivo
              </Button>
            </div>
          </TabPane>
        </TabContent>
      </ModalBody>
    </Modal>
  );
};

export default DeviceWizardModal;

---- File: src\pages\Devices\sections\index.tsx ----
// src/pages/Devices/sections/index.ts
export { default as DevicesKpis } from "./DevicesKpis";
export { default as DevicesTable } from "./DevicesTable";
export { default as DevicesMap  } from "./DevicesMap";
export { default as DevicesChart } from './DevicesChart';


---- File: src\pages\Devices\sections\MaintenanceModal.tsx ----
import classNames from 'classnames';
import React, { useState, useEffect } from 'react';
import {
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  Label,
  Input,
  FormGroup,
} from 'reactstrap';

interface MaintenanceModalProps {
  isOpen: boolean;
  toggle: () => void;
  device: any | null;
  onConfirm: (deviceId: number, reason: string) => void;
  onRemove: (deviceId: number) => void;
}

const MaintenanceModal: React.FC<MaintenanceModalProps> = ({ isOpen, toggle, device, onConfirm, onRemove }) => {
  const [reason, setReason] = useState("");

  // Determina si el dispositivo ya estÃ¡ en mantenimiento
  const isMaintenanceMode = device?.status === 'maintenance';

  // Carga el motivo existente cuando se abre el modal
  useEffect(() => {
    if (device && isOpen) {
      if (isMaintenanceMode) {
        setReason(device.maintenanceReason || "");
      } else {
        setReason(""); // Limpia el campo si se va a poner en mantenimiento
      }
    }
  }, [device, isOpen, isMaintenanceMode]);

  const handleConfirmClick = () => {
    if (device && reason.trim()) {
      onConfirm(device.id, reason.trim());
      toggle();
    }
  };

  const handleRemoveClick = () => {
    if (device) {
      onRemove(device.id);
      toggle();
    }
  };

  return (
    <Modal isOpen={isOpen} toggle={toggle} centered>
      <ModalHeader toggle={toggle}>
        <div className="d-flex align-items-center gap-2">
            <i className={classNames("fs-20", {
                "ri-tools-line text-primary": isMaintenanceMode,
                "ri-tools-fill text-warning": !isMaintenanceMode,
            })}></i>
            {isMaintenanceMode ? 'Gestionar Mantenimiento' : 'Poner en Mantenimiento'}
        </div>
      </ModalHeader>
      <ModalBody>
        <p className="text-muted">
          {isMaintenanceMode
            ? `EstÃ¡s gestionando el estado de mantenimiento del dispositivo `
            : `Vas a poner el dispositivo `}
          <strong className="text-dark">{device?.mssSerial}</strong>.
          {isMaintenanceMode
            ? ` Puedes actualizar la razÃ³n o quitarlo de este estado.`
            : ` Por favor, especifica una razÃ³n.`}
        </p>
        <FormGroup className='mt-3'>
          <Label htmlFor="maintenance-reason">
            {isMaintenanceMode ? 'RazÃ³n actual (puedes editarla)' : 'RazÃ³n del mantenimiento'}
          </Label>
          <Input
            id="maintenance-reason"
            type="textarea"
            rows="4"
            placeholder="Ej: Reemplazo de baterÃ­a, actualizaciÃ³n de firmware..."
            value={reason}
            onChange={(e) => setReason(e.target.value)}
          />
        </FormGroup>
      </ModalBody>
      <ModalFooter>
        {isMaintenanceMode ? (
            // Botones para cuando YA estÃ¡ en mantenimiento
            <>
                <Button color="light" onClick={toggle}>Cancelar</Button>
                <div className='hstack gap-2'>
                    <Button color="danger" outline onClick={handleRemoveClick}>Quitar de Mantenimiento</Button>
                    <Button color="primary" onClick={handleConfirmClick} disabled={!reason.trim()}>Actualizar</Button>
                </div>
            </>
        ) : (
            // Botones para poner EN mantenimiento
            <>
                <Button color="light" onClick={toggle}>Cancelar</Button>
                <Button color="primary" onClick={handleConfirmClick} disabled={!reason.trim()}>Confirmar</Button>
            </>
        )}
      </ModalFooter>
    </Modal>
  );
};

export default MaintenanceModal;

---- File: src\pages\Devices\sections\SettingsModal.tsx ----
import React, { useState, useEffect } from 'react';
import {
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  Row,
  Col,
  Label,
  Input,
  FormGroup,
} from 'reactstrap';

interface SettingsModalProps {
  isOpen: boolean;
  toggle: () => void;
  device: any | null;
  onSave: (deviceId: number, settings: any) => void;
}

const SettingsModal: React.FC<SettingsModalProps> = ({ isOpen, toggle, device, onSave }) => {
  // Estado para los valores de los lÃ­mites
  const [limits, setLimits] = useState({
    tempMin: '',
    tempMax: '',
    voltMin: '',
    voltMax: '',
  });

  // Estado para los switches de habilitaciÃ³n
  const [isTempEnabled, setIsTempEnabled] = useState(true);
  const [isVoltEnabled, setIsVoltEnabled] = useState(true);

  // Cargar datos del dispositivo cuando el modal se abre
  useEffect(() => {
    if (device) {
      setLimits({
        tempMin: device.tempMin?.toString() ?? '10',
        tempMax: device.tempMax?.toString() ?? '85',
        voltMin: device.voltMin?.toString() ?? '110',
        voltMax: device.voltMax?.toString() ?? '130',
      });
      setIsTempEnabled(device.isTempEnabled ?? true);
      setIsVoltEnabled(device.isVoltEnabled ?? true);
    }
  }, [device]);

  // Manejar cambios en los inputs, permitiendo solo nÃºmeros y un punto decimal
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    if (/^[0-9]*\.?[0-9]*$/.test(value)) {
      setLimits(prev => ({ ...prev, [name]: value }));
    }
  };

  const handleSaveClick = () => {
    if (!device) return;

    const newSettings = {
      tempMin: parseFloat(limits.tempMin) || 0,
      tempMax: parseFloat(limits.tempMax) || 0,
      isTempEnabled,
      voltMin: parseFloat(limits.voltMin) || 0,
      voltMax: parseFloat(limits.voltMax) || 0,
      isVoltEnabled,
    };
    onSave(device.id, newSettings);
    toggle(); // Cierra el modal
  };

  return (
    <Modal isOpen={isOpen} toggle={toggle} centered>
      <ModalHeader toggle={toggle}>Configurar LÃ­mites: {device?.mssSerial}</ModalHeader>
      <ModalBody>
        {/* SecciÃ³n de Temperatura */}
        <FormGroup className="border p-3 rounded">
          <div className="d-flex justify-content-between align-items-center mb-3">
            <Label className="mb-0 fs-15 fw-semibold">LÃ­mites de Temperatura (Â°C)</Label>
            <div className="form-check form-switch">
              <Input
                className="form-check-input"
                type="checkbox"
                role="switch"
                checked={isTempEnabled}
                onChange={() => setIsTempEnabled(!isTempEnabled)}
              />
            </div>
          </div>
          <Row>
            <Col>
              <Label htmlFor="tempMin">MÃ­nima</Label>
              <Input
                id="tempMin"
                name="tempMin"
                value={limits.tempMin}
                onChange={handleInputChange}
                placeholder="Ej: 10"
                disabled={!isTempEnabled}
              />
            </Col>
            <Col>
              <Label htmlFor="tempMax">MÃ¡xima</Label>
              <Input
                id="tempMax"
                name="tempMax"
                value={limits.tempMax}
                onChange={handleInputChange}
                placeholder="Ej: 85"
                disabled={!isTempEnabled}
              />
            </Col>
          </Row>
        </FormGroup>

        {/* SecciÃ³n de Voltaje */}
        <FormGroup className="border p-3 rounded mt-3">
          <div className="d-flex justify-content-between align-items-center mb-3">
            <Label className="mb-0 fs-15 fw-semibold">LÃ­mites de Voltaje (V)</Label>
            <div className="form-check form-switch">
              <Input
                className="form-check-input"
                type="checkbox"
                role="switch"
                checked={isVoltEnabled}
                onChange={() => setIsVoltEnabled(!isVoltEnabled)}
              />
            </div>
          </div>
          <Row>
            <Col>
              <Label htmlFor="voltMin">MÃ­nimo</Label>
              <Input
                id="voltMin"
                name="voltMin"
                value={limits.voltMin}
                onChange={handleInputChange}
                placeholder="Ej: 110"
                disabled={!isVoltEnabled}
              />
            </Col>
            <Col>
              <Label htmlFor="voltMax">MÃ¡ximo</Label>
              <Input
                id="voltMax"
                name="voltMax"
                value={limits.voltMax}
                onChange={handleInputChange}
                placeholder="Ej: 130"
                disabled={!isVoltEnabled}
              />
            </Col>
          </Row>
        </FormGroup>
      </ModalBody>
      <ModalFooter>
        <Button color="light" onClick={toggle}>
          Cancelar
        </Button>
        <Button color="primary" onClick={handleSaveClick}>
          Guardar Cambios
        </Button>
      </ModalFooter>
    </Modal>
  );
};

export default SettingsModal;

---- File: src\pages\Devices\Devices.tsx ----
import React, { useEffect, useState, useMemo } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import { Container, Modal, ModalHeader, ModalBody, ModalFooter, Button, Row, Col } from "reactstrap";
import { DevicesKpis, DevicesTable, DevicesMap, DevicesChart } from "./sections";
import DeviceWizardModal from "./sections/DeviceWizardModal";
import DeviceTestWizardModal from "./sections/DeviceTestWizardModal";
import SettingsModal from "./sections/SettingsModal";
import MaintenanceModal from "./sections/MaintenanceModal";
import { getDevicesKpis, getDevicesChartData } from "../../slices/device/thunk";
import { devicesMockData } from "../../common/data/devicesMockData";

const DevicesPage: React.FC = () => {
  const dispatch = useDispatch<any>();
  const navigate = useNavigate();
  
  const [devices, setDevices] = useState(devicesMockData);
  
  // CORRECCIÃ“N: Separar useSelector para evitar re-renderizados innecesarios.
  const kpis = useSelector((state: any) => state.Devices.kpis);
  const chartData = useSelector((state: any) => state.Devices.chartData);
  const chartLoading = useSelector((state: any) => state.Devices.chartLoading);

  // Filtros para la tabla
  const [yearFilter, setYearFilter] = useState<string>("all");
  const [monthFilter, setMonthFilter] = useState<string>("all");

  // Filtros para el grÃ¡fico
  const [chartYear, setChartYear] = useState<string>(() => new Date().getFullYear().toString());
  const [chartMonth, setChartMonth] = useState<string>(() => (new Date().getMonth() + 1).toString());
  
  // Estados para los modales
  const [isWizardOpen, setIsWizardOpen] = useState(false);
  const [isTestWizardOpen, setIsTestWizardOpen] = useState(false);
  const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
  const [isMaintenanceModalOpen, setIsMaintenanceModalOpen] = useState(false);

  // Estados para gestionar el dispositivo seleccionado en cada acciÃ³n
  const [deviceToEdit, setDeviceToEdit] = useState<any | null>(null);
  const [deviceToDelete, setDeviceToDelete] = useState<any | null>(null);
  const [deviceToTest, setDeviceToTest] = useState<any | null>(null);
  const [deviceToConfigure, setDeviceToConfigure] = useState<any | null>(null);
  const [deviceForMaintenance, setDeviceForMaintenance] = useState<any | null>(null);

  useEffect(() => {
    dispatch(getDevicesKpis());
  }, [dispatch]);

  // Este useEffect ahora se dispararÃ¡ correctamente en la carga inicial
  useEffect(() => {
    if (chartYear && chartMonth) {
      dispatch(getDevicesChartData({ 
        year: parseInt(chartYear), 
        month: parseInt(chartMonth) 
      }));
    }
  }, [dispatch, chartYear, chartMonth]);

  const availableYears = useMemo(() => {
    if (!devices || devices.length === 0) return [new Date().getFullYear()];
    const years = devices.map(d => new Date(d.lastUpdate).getFullYear());
    const uniqueYears = Array.from(new Set(years));
    const currentYear = new Date().getFullYear();
    if (!uniqueYears.includes(currentYear)) {
      uniqueYears.push(currentYear);
    }
    return uniqueYears.sort((a, b) => b - a);
  }, [devices]);

  const filteredDevices = useMemo(() => {
    return devices.filter(device => {
      if (!device.lastUpdate || isNaN(new Date(device.lastUpdate).getTime())) {
        return true;  
      }
      const deviceDate = new Date(device.lastUpdate);
      const yearMatch = yearFilter === 'all' || deviceDate.getFullYear() === parseInt(yearFilter);
      const monthMatch = monthFilter === 'all' || (deviceDate.getMonth() + 1) === parseInt(monthFilter);
      return yearMatch && monthMatch;
    });
  }, [devices, yearFilter, monthFilter]);
  
  const handleFilterChange = (filterType: 'year' | 'month', value: string) => {
    if (filterType === 'year') setYearFilter(value);
    if (filterType === 'month') setMonthFilter(value);
  };
  
  const handleChartFilterChange = (filterType: 'year' | 'month', value: string) => {
    if (filterType === 'year') setChartYear(value);
    if (filterType === 'month') setChartMonth(value);
  };
  
  const handleClearFilters = () => {
    setYearFilter("all");
    setMonthFilter("all");
  };

  const handleAddDevice = () => {
    setDeviceToEdit(null);
    setIsWizardOpen(true);
  };

  const handleEditDevice = (device: any) => {
    const flatDeviceData = {
        subName: device.substation, subLat: "18.4861", subLng: "-69.9312", spKind: "Circuito", spCode: device.supplyPoint,
        spName: `Punto de Suministro ${device.id}`, spStatus: "Active", unr: "", meterBrand: device.meterBrand, meterSerial: device.meterSerial,
        meterDate: new Date(device.lastUpdate).toISOString().split("T")[0], meterBrandBackup: "", meterSerialBackup: "", meterDateBackup: "",
        mssSerial: device.mssSerial, firmware: device.firmware || "1.0.0", devDate: new Date(device.lastUpdate).toISOString().split("T")[0], devStatus: device.status,
    };
    setDeviceToEdit(flatDeviceData);
    setIsWizardOpen(true);
  };

  const handleDeleteDevice = (device: any) => { setDeviceToDelete(device); };
  const handleViewAlarms = (device: any) => { navigate(`/alarms?deviceId=${device.id}`); };
  const handleTestDevice = (device: any) => { setDeviceToTest(device); setIsTestWizardOpen(true); };
  const handleConfigureDevice = (device: any) => { setDeviceToConfigure(device); setIsSettingsModalOpen(true); };
  const handleMaintenanceDevice = (device: any) => { setDeviceForMaintenance(device); setIsMaintenanceModalOpen(true); };
  
  const handleSaveDevice = (deviceData: any) => {
    const now = new Date().toISOString();
    if (deviceToEdit) {
      setDevices(devices.map(d => (d.id === deviceToEdit.id ? { ...d, ...deviceData, lastUpdate: now } : d) ));
    } else {
      const newId = devices.length > 0 ? Math.max(...devices.map(d => d.id)) + 1 : 1;
      setDevices([...devices, { ...deviceData, id: newId, lastUpdate: now }]);
    }
  };

  const handleSaveSettings = (deviceId: number, newSettings: any) => { setDevices(prev => prev.map(d => d.id === deviceId ? { ...d, ...newSettings } : d)); };
  const handleConfirmMaintenance = (deviceId: number, reason: string) => { setDevices(prev => prev.map(d => d.id === deviceId ? { ...d, status: 'maintenance', maintenanceReason: reason } : d)); };
  const handleRemoveMaintenance = (deviceId: number) => { setDevices(prev => prev.map(d => d.id === deviceId ? { ...d, status: 'online', maintenanceReason: undefined } : d)); };

  const confirmDelete = () => {
    if (deviceToDelete) {
      setDevices(devices.filter(d => d.id !== deviceToDelete.id));
      setDeviceToDelete(null);
    }
  };

  return (
    <div className="page-content">
      <Container fluid>
        <h4 className="mb-4">Dashboard de Dispositivos</h4>
        <DevicesKpis items={kpis} />
        <DevicesTable
          title="Listado de Dispositivos"
          rows={filteredDevices}
          onAddDevice={handleAddDevice}
          onEditDevice={handleEditDevice}
          onDeleteDevice={handleDeleteDevice}
          onMaintenanceDevice={handleMaintenanceDevice}
          onViewAlarms={handleViewAlarms}
          onTestDevice={handleTestDevice}
          onConfigureDevice={handleConfigureDevice}
          availableYears={availableYears}
          yearFilter={yearFilter}
          monthFilter={monthFilter}
          onFilterChange={handleFilterChange}
          onClearFilters={handleClearFilters}
        />
        <DevicesMap
          devices={filteredDevices}
          title="Mapa de Ubicaciones de Dispositivos"
        />
        <Row>
          <Col lg={12}>
            <DevicesChart
              data={chartData}
              loading={chartLoading}
              availableYears={availableYears}
              yearFilter={chartYear}
              monthFilter={chartMonth}
              onFilterChange={handleChartFilterChange}
            />
          </Col>
        </Row>
        {/* --- MODALES --- */}
        <DeviceWizardModal isOpen={isWizardOpen} toggle={() => setIsWizardOpen(false)} onSave={handleSaveDevice} deviceToEdit={deviceToEdit} />
        <DeviceTestWizardModal isOpen={isTestWizardOpen} toggle={() => setIsTestWizardOpen(false)} device={deviceToTest} />
        <SettingsModal isOpen={isSettingsModalOpen} toggle={() => setIsSettingsModalOpen(false)} device={deviceToConfigure} onSave={handleSaveSettings} />
        <MaintenanceModal isOpen={isMaintenanceModalOpen} toggle={() => setIsMaintenanceModalOpen(false)} device={deviceForMaintenance} onConfirm={handleConfirmMaintenance} onRemove={handleRemoveMaintenance} />
        <Modal isOpen={!!deviceToDelete} toggle={() => setDeviceToDelete(null)} centered>
            <ModalHeader toggle={() => setDeviceToDelete(null)}> Confirmar EliminaciÃ³n </ModalHeader>
            <ModalBody> Â¿EstÃ¡s seguro de que deseas eliminar el dispositivo <strong>{deviceToDelete?.mssSerial}</strong>? </ModalBody>
            <ModalFooter>
                <Button color="light" onClick={() => setDeviceToDelete(null)}>Cancelar</Button>
                <Button color="danger" onClick={confirmDelete}>Eliminar</Button>
            </ModalFooter>
        </Modal>
      </Container>
    </div>
  );
};

export default DevicesPage;

